<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="gio-2.0"/>
  <package name="gio-unix-2.0"/>
  <c:include name="gio/gdesktopappinfo.h"/>
  <c:include name="gio/gfiledescriptorbased.h"/>
  <c:include name="gio/gio.h"/>
  <c:include name="gio/gunixfdmessage.h"/>
  <c:include name="gio/gunixinputstream.h"/>
  <c:include name="gio/gunixmounts.h"/>
  <c:include name="gio/gunixoutputstream.h"/>
  <namespace name="Gio"
             version="2.0"
             shared-library="libgio-2.0.so.0"
             c:identifier-prefixes="G"
             c:symbol-prefixes="gio,g">
    <function-macro name="ACTION" c:identifier="G_ACTION" introspectable="0">
      <source-position filename="gio/gaction.h" line="34"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ACTION_GET_IFACE"
                    c:identifier="G_ACTION_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gaction.h" line="37"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ACTION_GROUP"
                    c:identifier="G_ACTION_GROUP"
                    introspectable="0">
      <source-position filename="gio/gactiongroup.h" line="35"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ACTION_GROUP_GET_IFACE"
                    c:identifier="G_ACTION_GROUP_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gactiongroup.h" line="39"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ACTION_MAP"
                    c:identifier="G_ACTION_MAP"
                    introspectable="0">
      <source-position filename="gio/gactionmap.h" line="35"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ACTION_MAP_GET_IFACE"
                    c:identifier="G_ACTION_MAP_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gactionmap.h" line="39"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION"
                    c:identifier="G_APPLICATION"
                    introspectable="0">
      <source-position filename="gio/gapplication.h" line="34"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION_CLASS"
                    c:identifier="G_APPLICATION_CLASS"
                    introspectable="0">
      <source-position filename="gio/gapplication.h" line="36"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION_COMMAND_LINE"
                    c:identifier="G_APPLICATION_COMMAND_LINE"
                    introspectable="0">
      <source-position filename="gio/gapplicationcommandline.h" line="35"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION_COMMAND_LINE_CLASS"
                    c:identifier="G_APPLICATION_COMMAND_LINE_CLASS"
                    introspectable="0">
      <source-position filename="gio/gapplicationcommandline.h" line="38"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION_COMMAND_LINE_GET_CLASS"
                    c:identifier="G_APPLICATION_COMMAND_LINE_GET_CLASS"
                    introspectable="0">
      <source-position filename="gio/gapplicationcommandline.h" line="45"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APPLICATION_GET_CLASS"
                    c:identifier="G_APPLICATION_GET_CLASS"
                    introspectable="0">
      <source-position filename="gio/gapplication.h" line="40"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_INFO"
                    c:identifier="G_APP_INFO"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_INFO_GET_IFACE"
                    c:identifier="G_APP_INFO_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_INFO_MONITOR"
                    c:identifier="G_APP_INFO_MONITOR"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="362"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_LAUNCH_CONTEXT"
                    c:identifier="G_APP_LAUNCH_CONTEXT"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="40"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_LAUNCH_CONTEXT_CLASS"
                    c:identifier="G_APP_LAUNCH_CONTEXT_CLASS"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="41"/>
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="APP_LAUNCH_CONTEXT_GET_CLASS"
                    c:identifier="G_APP_LAUNCH_CONTEXT_GET_CLASS"
                    introspectable="0">
      <source-position filename="gio/gappinfo.h" line="44"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ASYNC_INITABLE"
                    c:identifier="G_ASYNC_INITABLE"
                    introspectable="0">
      <source-position filename="gio/gasyncinitable.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ASYNC_INITABLE_GET_IFACE"
                    c:identifier="G_ASYNC_INITABLE_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gasyncinitable.h" line="38"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ASYNC_RESULT"
                    c:identifier="G_ASYNC_RESULT"
                    introspectable="0">
      <source-position filename="gio/gasyncresult.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ASYNC_RESULT_GET_IFACE"
                    c:identifier="G_ASYNC_RESULT_GET_IFACE"
                    introspectable="0">
      <source-position filename="gio/gasyncresult.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <interface name="Action"
               c:symbol-prefix="action"
               c:type="GAction"
               glib:type-name="GAction"
               glib:get-type="g_action_get_type"
               glib:type-struct="ActionInterface">
      <doc xml:space="preserve"
           filename="gio/gaction.c"
           line="30">`GAction` represents a single named action.

The main interface to an action is that it can be activated with
[method@Gio.Action.activate]. This results in the 'activate' signal being
emitted. An activation has a `GVariant` parameter (which may be
`NULL`). The correct type for the parameter is determined by a static
parameter type (which is given at construction time).

An action may optionally have a state, in which case the state may be
set with [method@Gio.Action.change_state]. This call takes a [type@GLib.Variant]. The
correct type for the state is determined by a static state type
(which is given at construction time).

The state may have a hint associated with it, specifying its valid
range.

`GAction` is merely the interface to the concept of an action, as
described above.  Various implementations of actions exist, including
[class@Gio.SimpleAction].

In all cases, the implementing class is responsible for storing the
name of the action, the parameter type, the enabled state, the optional
state type and the state and emitting the appropriate signals when these
change. The implementor is responsible for filtering calls to
[method@Gio.Action.activate] and [method@Gio.Action.change_state]
for type safety and for the state being enabled.

Probably the only useful thing to do with a `GAction` is to put it
inside of a [class@Gio.SimpleActionGroup].</doc>
      <source-position filename="gio/gaction.h" line="59"/>
      <function name="name_is_valid"
                c:identifier="g_action_name_is_valid"
                version="2.38">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="387">Checks if @action_name is valid.

@action_name is valid if it consists only of alphanumeric characters,
plus `-` and `.`.  The empty string is not a valid action name.

It is an error to call this function with a non-UTF-8 @action_name.
@action_name must not be `NULL`.</doc>
        <source-position filename="gio/gaction.h" line="86"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="399">`TRUE` if @action_name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="389">a potential action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_detailed_name"
                c:identifier="g_action_parse_detailed_name"
                version="2.38"
                throws="1">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="418">Parses a detailed action name into its separate name and target
components.

Detailed action names can have three formats.

The first format is used to represent an action name with no target
value and consists of just an action name containing no whitespace
nor the characters `:`, `(` or `)`.  For example: `app.action`.

The second format is used to represent an action with a target value
that is a non-empty string consisting only of alphanumerics, plus `-`
and `.`.  In that case, the action name and target value are
separated by a double colon (`::`).  For example:
`app.action::target`.

The third format is used to represent an action with any type of
target value, including strings.  The target value follows the action
name, surrounded in parens.  For example: `app.action(42)`.  The
target value is parsed using [func@GLib.Variant.parse].  If a tuple-typed
value is desired, it must be specified in the same way, resulting in
two sets of parens, for example: `app.action((1,2,3))`.  A string
target can be specified this way as well: `app.action('target')`.
For strings, this third format must be used if target value is
empty or contains characters other than alphanumerics, `-` and `.`.

If this function returns `TRUE`, a non-`NULL` value is guaranteed to be returned
in @action_name (if a pointer is passed in). A `NULL` value may still be
returned in @target_value, as the @detailed_name may not contain a target.

If returned, the [type@GLib.Variant] in @target_value is guaranteed to not be floating.</doc>
        <source-position filename="gio/gaction.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="457">`TRUE` if successful, else `FALSE` with @error set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="detailed_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="420">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="421">the action name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="target_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="422">the target value,
  or `NULL` for no target</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </function>
      <function name="print_detailed_name"
                c:identifier="g_action_print_detailed_name"
                version="2.38">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="532">Formats a detailed action name from @action_name and @target_value.

It is an error to call this function with an invalid action name.

This function is the opposite of [func@Gio.Action.parse_detailed_name].
It will produce a string that can be parsed back to the @action_name
and @target_value by that function.

See that function for the types of strings that will be printed by
this function.</doc>
        <source-position filename="gio/gaction.h" line="95"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="548">a detailed format string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="534">a valid action name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target_value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="535">a [type@GLib.Variant] target value, or `NULL`</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="356">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was `NULL` then @parameter must also be `NULL`.

If the @parameter [type@GLib.Variant] is floating, it is consumed.</doc>
        <source-position filename="gio/gaction.h" line="57"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="358">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="parameter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="359">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="change_state"
                      invoker="change_state"
                      version="2.30">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="158">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See [method@Gio.Action.get_state_type].

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See [method@Gio.Action.get_state_hint].

If the @value [type@GLib.Variant] is floating, it is consumed.</doc>
        <source-position filename="gio/gaction.h" line="55"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="160">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="161">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_enabled" invoker="get_enabled" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="334">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gio/gaction.h" line="52"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="343">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="336">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="222">Queries the name of @action.</doc>
        <source-position filename="gio/gaction.h" line="47"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="228">the name of the action</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="224">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parameter_type"
                      invoker="get_parameter_type"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="241">Queries the type of the parameter that must be given when activating
@action.

When activating the action using [method@Gio.Action.activate], the
[type@GLib.Variant] given to that function must be of the type returned by
this function.

In the case that this function returns `NULL`, you must not give any
[type@GLib.Variant], but `NULL` instead.</doc>
        <source-position filename="gio/gaction.h" line="48"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="255">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="243">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="196">Queries the current state of @action.

If the action is not stateful then `NULL` will be returned.  If the
action is stateful then the type of the return value is the type
given by [method@Gio.Action.get_state_type].

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gaction.h" line="53"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="209">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="198">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_hint"
                      invoker="get_state_hint"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="298">Requests a hint about the valid range of values for the state of
@action.

If `NULL` is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a [type@GLib.Variant] array is returned then each item in the array is a
possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gaction.h" line="50"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="321">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="300">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_type"
                      invoker="get_state_type"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="268">Queries the type of the state of @action.

If the action is stateful (e.g. created with
[ctor@Gio.SimpleAction.new_stateful]) then this function returns the
[type@GLib.VariantType] of the state.  This is the type of the initial value
given as the state. All calls to [method@Gio.Action.change_state] must give a
[type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
[type@GLib.Variant] of the same type.

If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
will return `NULL` and you must not call [method@Gio.Action.change_state].</doc>
        <source-position filename="gio/gaction.h" line="49"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="285">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="270">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="g_action_activate" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="356">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was `NULL` then @parameter must also be `NULL`.

If the @parameter [type@GLib.Variant] is floating, it is consumed.</doc>
        <source-position filename="gio/gaction.h" line="82"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="358">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="parameter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="359">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_state"
              c:identifier="g_action_change_state"
              version="2.30">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="158">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See [method@Gio.Action.get_state_type].

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See [method@Gio.Action.get_state_hint].

If the @value [type@GLib.Variant] is floating, it is consumed.</doc>
        <source-position filename="gio/gaction.h" line="79"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="160">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="161">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enabled"
              c:identifier="g_action_get_enabled"
              glib:get-property="enabled"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="334">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gio/gaction.h" line="74"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="343">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="336">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="g_action_get_name"
              glib:get-property="name"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="222">Queries the name of @action.</doc>
        <source-position filename="gio/gaction.h" line="65"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="228">the name of the action</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="224">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameter_type"
              c:identifier="g_action_get_parameter_type"
              glib:get-property="parameter-type"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="241">Queries the type of the parameter that must be given when activating
@action.

When activating the action using [method@Gio.Action.activate], the
[type@GLib.Variant] given to that function must be of the type returned by
this function.

In the case that this function returns `NULL`, you must not give any
[type@GLib.Variant], but `NULL` instead.</doc>
        <source-position filename="gio/gaction.h" line="67"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="255">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="243">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="g_action_get_state"
              glib:get-property="state"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="196">Queries the current state of @action.

If the action is not stateful then `NULL` will be returned.  If the
action is stateful then the type of the return value is the type
given by [method@Gio.Action.get_state_type].

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gaction.h" line="76"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="209">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="198">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_hint"
              c:identifier="g_action_get_state_hint"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="298">Requests a hint about the valid range of values for the state of
@action.

If `NULL` is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a [type@GLib.Variant] array is returned then each item in the array is a
possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gaction.h" line="71"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="321">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="300">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_type"
              c:identifier="g_action_get_state_type"
              glib:get-property="state-type"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="268">Queries the type of the state of @action.

If the action is stateful (e.g. created with
[ctor@Gio.SimpleAction.new_stateful]) then this function returns the
[type@GLib.VariantType] of the state.  This is the type of the initial value
given as the state. All calls to [method@Gio.Action.change_state] must give a
[type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
[type@GLib.Variant] of the same type.

If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
will return `NULL` and you must not call [method@Gio.Action.change_state].</doc>
        <source-position filename="gio/gaction.h" line="69"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gaction.c"
               line="285">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="270">a [type@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="enabled"
                version="2.28"
                transfer-ownership="none"
                getter="get_enabled"
                default-value="TRUE">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="113">If @action is currently enabled.

If the action is disabled then calls to [method@Gio.Action.activate] and
[method@Gio.Action.change_state] have no effect.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="name"
                version="2.28"
                transfer-ownership="none"
                getter="get_name"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="84">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a [type@Gio.ActionGroup]. It is immutable.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parameter-type"
                version="2.28"
                transfer-ownership="none"
                getter="get_parameter_type">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="98">The type of the parameter that must be given when activating the
action. This is immutable, and may be `NULL` if no parameter is needed when
activating the action.</doc>
        <type name="GLib.VariantType"/>
      </property>
      <property name="state"
                version="2.28"
                transfer-ownership="none"
                getter="get_state">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="143">The state of the action, or `NULL` if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type"
                version="2.28"
                transfer-ownership="none"
                getter="get_state_type">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="129">The [type@GLib.VariantType] of the state that the action has, or `NULL` if the
action is stateless. This is immutable.</doc>
        <type name="GLib.VariantType"/>
      </property>
    </interface>
    <record name="ActionEntry" c:type="GActionEntry">
      <doc xml:space="preserve"
           filename="gio/gactionmap.c"
           line="127">This struct defines a single action.  It is for use with
[method@Gio.ActionMap.add_action_entries].

The order of the items in the structure are intended to reflect
frequency of use.  It is permissible to use an incomplete initialiser
in order to leave some of the later values as `NULL`.  All values
after @name are optional.  Additional optional fields may be added in
the future.

See [method@Gio.ActionMap.add_action_entries] for an example.</doc>
      <source-position filename="gio/gactionmap.h" line="75"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="129">the name of the action</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="activate">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="130">the callback to connect to the "activate" signal of the action.
  Since GLib 2.40, this can be `NULL` for stateful actions, in which case
  the default handler is used. For boolean-stated actions with no
  parameter, this is a toggle. For other state types (and parameter type
  equal to the state type) this will be a function that just calls
  @change_state (which you should provide).</doc>
        <callback name="activate">
          <source-position filename="gio/gactionmap.h" line="61"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="SimpleAction" c:type="GSimpleAction*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parameter_type" writable="1">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="136">the type of the parameter that must be passed to the
  activate function for this action, given as a single GVariant type string
  (or `NULL` for no parameter)</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="state" writable="1">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="139">the initial state for this action, given in
  [GVariant text format](gvariant-text-format.html).  The state is parsed
  with no extra type information, so type tags must be added to the string
  if they are necessary.  Stateless actions should give `NULL` here.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="change_state">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="143">the callback to connect to the "change-state" signal of the
  action.  All stateful actions should provide a handler here; stateless
  actions should not.</doc>
        <callback name="change_state">
          <source-position filename="gio/gactionmap.h" line="69"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="SimpleAction" c:type="GSimpleAction*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="3">
          <type name="gsize" c:type="gsize"/>
        </array>
      </field>
    </record>
    <interface name="ActionGroup"
               c:symbol-prefix="action_group"
               c:type="GActionGroup"
               glib:type-name="GActionGroup"
               glib:get-type="g_action_group_get_type"
               glib:type-struct="ActionGroupInterface">
      <doc xml:space="preserve"
           filename="gio/gactiongroup.c"
           line="28">`GActionGroup` represents a group of actions.

Actions can be used to expose functionality in a structured way, either
from one part of a program to another, or to the outside world. Action
groups are often used together with a [type@Gio.MenuModel] that provides additional
representation data for displaying the actions to the user, e.g. in a menu.

The main way to interact with the actions in a `GActionGroup` is to
activate them with [method@Gio.ActionGroup.activate_action]. Activating an
action may require a [type@GLib.Variant] parameter. The required type of the
parameter can be inquired with [method@Gio.ActionGroup.get_action_parameter_type].
Actions may be disabled, see [method@Gio.ActionGroup.get_action_enabled].
Activating a disabled action has no effect.

Actions may optionally have a state in the form of a [type@GLib.Variant]. The current
state of an action can be inquired with [method@Gio.ActionGroup.get_action_state].
Activating a stateful action may change its state, but it is also possible to
set the state by calling [method@Gio.ActionGroup.change_action_state].

As typical example, consider a text editing application which has an
option to change the current font to ‘bold’. A good way to represent
this would be a stateful action, with a boolean state. Activating the
action would toggle the state.

Each action in the group has a unique name (which is a string).  All
method calls, except [method@Gio.ActionGroup.list_actions] take the name of
an action as an argument.

The `GActionGroup` API is meant to be the ‘public’ API to the action
group. The calls here are exactly the interaction that ‘external
forces’ (eg: UI, incoming D-Bus messages, etc.) are supposed to have
with actions. ‘Internal’ APIs (ie: ones meant only to be accessed by
the action group implementation) are found on subclasses. This is
why you will find – for example – [method@Gio.ActionGroup.get_action_enabled]
but not an equivalent `set_action_enabled()` method.

Signals are emitted on the action group in response to state changes
on individual actions.

Implementations of `GActionGroup` should provide implementations for
the virtual functions [method@Gio.ActionGroup.list_actions] and
[method@Gio.ActionGroup.query_action]. The other virtual functions should
not be implemented — their ‘wrappers’ are actually implemented with
calls to [method@Gio.ActionGroup.query_action].</doc>
      <source-position filename="gio/gactiongroup.h" line="97"/>
      <virtual-method name="action_added"
                      invoker="action_added"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="628">Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="78"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="630">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="631">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_enabled_changed"
                      invoker="action_enabled_changed"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="676">Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="82"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="678">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="679">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="680">whether the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_removed"
                      invoker="action_removed"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="652">Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="654">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="655">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="action_state_changed"
                      invoker="action_state_changed"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="705">Emits the [signal@Gio.ActionGroup::action-state-changed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="85"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="707">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="708">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="709">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate_action"
                      invoker="activate_action"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="574">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be `NULL`.  See
[method@Gio.ActionGroup.get_action_parameter_type].

If the [type@Gio.ActionGroup] implementation supports asynchronous remote
activation over D-Bus, this call may return before the relevant
D-Bus traffic has been sent, or any replies have been received. In
order to block on such asynchronous activation calls,
[method@Gio.DBusConnection.flush] should be called prior to the code, which
depends on the result of the action activation. Without flushing
the D-Bus connection, there is no guarantee that the action would
have been activated.

The following code which runs in a remote app instance, shows an
example of a ‘quit’ action being activated on the primary app
instance over D-Bus. Here [method@Gio.DBusConnection.flush] is called
before `exit()`. Without `g_dbus_connection_flush()`, the ‘quit’ action
may fail to be activated on the primary instance.

```c
// call ‘quit’ action on primary instance
g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);

// make sure the action is activated now
g_dbus_connection_flush (…);

g_debug ("Application has been terminated. Exiting.");

exit (0);
```</doc>
        <source-position filename="gio/gactiongroup.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="576">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="577">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="578">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="change_action_state"
                      invoker="change_action_state"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="541">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See [method@Gio.ActionGroup.get_action_state_type].

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See [method@Gio.ActionGroup.get_action_state_hint].

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gio/gactiongroup.h" line="69"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="543">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="544">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="545">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_enabled"
                      invoker="get_action_enabled"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="489">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gio/gactiongroup.h" line="54"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="499">whether the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="491">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="492">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_parameter_type"
                      invoker="get_action_parameter_type"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="382">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using [method@Gio.ActionGroup.activate_action],
the [type@GLib.Variant] given to that function must be of the type returned
by this function.

In the case that this function returns `NULL`, you must not give any
[type@GLib.Variant], but `NULL` instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <source-position filename="gio/gactiongroup.h" line="57"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="401">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="384">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="385">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state"
                      invoker="get_action_state"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="513">Queries the current state of the named action within @action_group.

If the action is not stateful then `NULL` will be returned.  If the
action is stateful then the type of the return value is the type
given by [method@Gio.ActionGroup.get_action_state_type].

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="66"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="527">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="515">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="516">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state_hint"
                      invoker="get_action_state_hint"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="451">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If `NULL` is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a [type@GLib.Variant] array is returned then each item in the array is a
possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="63"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="475">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="453">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="454">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_action_state_type"
                      invoker="get_action_state_type"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="415">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
[type@GLib.VariantType] of the state.  All calls to
[method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
of the same type.

If the action is not stateful then this function will return `NULL`.
In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
and you must not call [method@Gio.ActionGroup.change_action_state].

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <source-position filename="gio/gactiongroup.h" line="60"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="437">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="417">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="418">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_action" invoker="has_action" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="361">Checks if the named action exists within @action_group.</doc>
        <source-position filename="gio/gactiongroup.h" line="49"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="368">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="363">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="364">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_actions"
                      invoker="list_actions"
                      version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="338">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with [func@GLib.strfreev] when
it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="52"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="347">a `NULL`-terminated array
  of the names of the actions in the group</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="340">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_action"
                      invoker="query_action"
                      version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="732">Queries all aspects of the named action within an @action_group.

This function acquires the information available from
[method@Gio.ActionGroup.has_action], [method@Gio.ActionGroup.get_action_enabled],
[method@Gio.ActionGroup.get_action_parameter_type],
[method@Gio.ActionGroup.get_action_state_type],
[method@Gio.ActionGroup.get_action_state_hint] and
[method@Gio.ActionGroup.get_action_state] with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
[type@Gio.ActionGroup] can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, `TRUE` is returned and any of the requested
fields (as indicated by having a non-`NULL` reference passed in) are
filled.  If the action doesn’t exist, `FALSE` is returned and the
fields may or may not have been modified.</doc>
        <source-position filename="gio/gactiongroup.h" line="90"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="770">`TRUE` if the action exists, else `FALSE`</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="734">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="735">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="736">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="parameter_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="737">the parameter type, or `NULL` if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="738">the state type, or `NULL` if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_hint"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="739">the state hint, or `NULL` if none</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="740">the current state, or `NULL` if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="action_added"
              c:identifier="g_action_group_action_added"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="628">Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="137"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="630">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="631">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_enabled_changed"
              c:identifier="g_action_group_action_enabled_changed"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="676">Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="678">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="679">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="680">whether the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_removed"
              c:identifier="g_action_group_action_removed"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="652">Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="140"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="654">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="655">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_state_changed"
              c:identifier="g_action_group_action_state_changed"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="705">Emits the [signal@Gio.ActionGroup::action-state-changed] signal on @action_group.

This function should only be called by [type@Gio.ActionGroup] implementations.</doc>
        <source-position filename="gio/gactiongroup.h" line="148"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="707">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="708">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="709">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate_action"
              c:identifier="g_action_group_activate_action"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="574">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be `NULL`.  See
[method@Gio.ActionGroup.get_action_parameter_type].

If the [type@Gio.ActionGroup] implementation supports asynchronous remote
activation over D-Bus, this call may return before the relevant
D-Bus traffic has been sent, or any replies have been received. In
order to block on such asynchronous activation calls,
[method@Gio.DBusConnection.flush] should be called prior to the code, which
depends on the result of the action activation. Without flushing
the D-Bus connection, there is no guarantee that the action would
have been activated.

The following code which runs in a remote app instance, shows an
example of a ‘quit’ action being activated on the primary app
instance over D-Bus. Here [method@Gio.DBusConnection.flush] is called
before `exit()`. Without `g_dbus_connection_flush()`, the ‘quit’ action
may fail to be activated on the primary instance.

```c
// call ‘quit’ action on primary instance
g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);

// make sure the action is activated now
g_dbus_connection_flush (…);

g_debug ("Application has been terminated. Exiting.");

exit (0);
```</doc>
        <source-position filename="gio/gactiongroup.h" line="131"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="576">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="577">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="parameter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="578">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_action_state"
              c:identifier="g_action_group_change_action_state"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="541">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See [method@Gio.ActionGroup.get_action_state_type].

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See [method@Gio.ActionGroup.get_action_state_hint].

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gio/gactiongroup.h" line="126"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="543">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="544">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="545">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_enabled"
              c:identifier="g_action_group_get_action_enabled"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="489">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gio/gactiongroup.h" line="119"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="499">whether the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="491">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="492">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_parameter_type"
              c:identifier="g_action_group_get_action_parameter_type"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="382">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using [method@Gio.ActionGroup.activate_action],
the [type@GLib.Variant] given to that function must be of the type returned
by this function.

In the case that this function returns `NULL`, you must not give any
[type@GLib.Variant], but `NULL` instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <source-position filename="gio/gactiongroup.h" line="109"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="401">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="384">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="385">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state"
              c:identifier="g_action_group_get_action_state"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="513">Queries the current state of the named action within @action_group.

If the action is not stateful then `NULL` will be returned.  If the
action is stateful then the type of the return value is the type
given by [method@Gio.ActionGroup.get_action_state_type].

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="123"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="527">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="515">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="516">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state_hint"
              c:identifier="g_action_group_get_action_state_hint"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="451">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If `NULL` is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a [type@GLib.Variant] array is returned then each item in the array is a
possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-`NULL`) should be freed with
[method@GLib.Variant.unref] when it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="115"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="475">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="453">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="454">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_state_type"
              c:identifier="g_action_group_get_action_state_type"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="415">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
[type@GLib.VariantType] of the state.  All calls to
[method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
of the same type.

If the action is not stateful then this function will return `NULL`.
In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
and you must not call [method@Gio.ActionGroup.change_action_state].

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <source-position filename="gio/gactiongroup.h" line="112"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="437">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="417">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="418">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_action"
              c:identifier="g_action_group_has_action"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="361">Checks if the named action exists within @action_group.</doc>
        <source-position filename="gio/gactiongroup.h" line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="368">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="363">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="364">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_actions"
              c:identifier="g_action_group_list_actions"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="338">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with [func@GLib.strfreev] when
it is no longer required.</doc>
        <source-position filename="gio/gactiongroup.h" line="106"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="347">a `NULL`-terminated array
  of the names of the actions in the group</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="340">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_action"
              c:identifier="g_action_group_query_action"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="732">Queries all aspects of the named action within an @action_group.

This function acquires the information available from
[method@Gio.ActionGroup.has_action], [method@Gio.ActionGroup.get_action_enabled],
[method@Gio.ActionGroup.get_action_parameter_type],
[method@Gio.ActionGroup.get_action_state_type],
[method@Gio.ActionGroup.get_action_state_hint] and
[method@Gio.ActionGroup.get_action_state] with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
[type@Gio.ActionGroup] can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, `TRUE` is returned and any of the requested
fields (as indicated by having a non-`NULL` reference passed in) are
filled.  If the action doesn’t exist, `FALSE` is returned and the
fields may or may not have been modified.</doc>
        <source-position filename="gio/gactiongroup.h" line="153"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gactiongroup.c"
               line="770">`TRUE` if the action exists, else `FALSE`</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="734">a [type@Gio.ActionGroup]</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="735">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enabled"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="736">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="parameter_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="737">the parameter type, or `NULL` if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="738">the state type, or `NULL` if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**"/>
          </parameter>
          <parameter name="state_hint"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="739">the state hint, or `NULL` if none</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="740">the current state, or `NULL` if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="action-added" when="last" detailed="1" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="241">Signals that a new action was just added to the group.

This signal is emitted after the action has been added
and is now visible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="244">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-enabled-changed"
                   when="last"
                   detailed="1"
                   version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="285">Signals that the enabled status of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="288">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="289">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-removed"
                   when="last"
                   detailed="1"
                   version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="263">Signals that an action is just about to be removed from the group.

This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="266">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-state-changed"
                   when="last"
                   detailed="1"
                   version="2.28">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="310">Signals that the state of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="313">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="314">the new value of the state</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ActionGroupInterface"
            c:type="GActionGroupInterface"
            glib:is-gtype-struct-for="ActionGroup"
            version="2.28">
      <doc xml:space="preserve"
           filename="gio/gactiongroup.c"
           line="77">The virtual function table for [type@Gio.ActionGroup].</doc>
      <source-position filename="gio/gactiongroup.h" line="97"/>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="has_action">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="79">the virtual function pointer for [method@Gio.ActionGroup.has_action]</doc>
        <callback name="has_action">
          <source-position filename="gio/gactiongroup.h" line="49"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="368">whether the named action exists</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="363">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="364">the name of the action to check for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_actions">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="80">the virtual function pointer for [method@Gio.ActionGroup.list_actions]</doc>
        <callback name="list_actions">
          <source-position filename="gio/gactiongroup.h" line="52"/>
          <return-value transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="347">a `NULL`-terminated array
  of the names of the actions in the group</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="340">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_enabled">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="84">the virtual function pointer for [method@Gio.ActionGroup.get_action_enabled]</doc>
        <callback name="get_action_enabled">
          <source-position filename="gio/gactiongroup.h" line="54"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="499">whether the action is currently enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="491">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="492">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_parameter_type">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="81">the virtual function pointer for [method@Gio.ActionGroup.get_action_parameter_type]</doc>
        <callback name="get_action_parameter_type">
          <source-position filename="gio/gactiongroup.h" line="57"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="401">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="384">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="385">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state_type">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="82">the virtual function pointer for [method@Gio.ActionGroup.get_action_state_type]</doc>
        <callback name="get_action_state_type">
          <source-position filename="gio/gactiongroup.h" line="60"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="437">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="417">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="418">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state_hint">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="83">the virtual function pointer for [method@Gio.ActionGroup.get_action_state_hint]</doc>
        <callback name="get_action_state_hint">
          <source-position filename="gio/gactiongroup.h" line="63"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="475">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="453">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="454">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_action_state">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="85">the virtual function pointer for [method@Gio.ActionGroup.get_action_state]</doc>
        <callback name="get_action_state">
          <source-position filename="gio/gactiongroup.h" line="66"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="527">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="515">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="516">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_action_state">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="86">the virtual function pointer for [method@Gio.ActionGroup.change_action_state]</doc>
        <callback name="change_action_state">
          <source-position filename="gio/gactiongroup.h" line="69"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="543">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="544">the name of the action to request the change on</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="545">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate_action">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="87">the virtual function pointer for [method@Gio.ActionGroup.activate_action]</doc>
        <callback name="activate_action">
          <source-position filename="gio/gactiongroup.h" line="73"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="576">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="577">the name of the action to activate</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="parameter"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="578">parameters to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_added">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="88">the class closure for the [signal@Gio.ActionGroup::action-added] signal</doc>
        <callback name="action_added">
          <source-position filename="gio/gactiongroup.h" line="78"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="630">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="631">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_removed">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="89">the class closure for the [signal@Gio.ActionGroup::action-removed] signal</doc>
        <callback name="action_removed">
          <source-position filename="gio/gactiongroup.h" line="80"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="654">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="655">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_enabled_changed">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="90">the class closure for the [signal@Gio.ActionGroup::action-enabled-changed] signal</doc>
        <callback name="action_enabled_changed">
          <source-position filename="gio/gactiongroup.h" line="82"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="678">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="679">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="enabled" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="680">whether the action is now enabled</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_state_changed">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="91">the class closure for the [signal@Gio.ActionGroup::action-enabled-changed] signal</doc>
        <callback name="action_state_changed">
          <source-position filename="gio/gactiongroup.h" line="85"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="707">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="708">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="709">the new state of the named action</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_action">
        <doc xml:space="preserve"
             filename="gio/gactiongroup.c"
             line="92">the virtual function pointer for [method@Gio.ActionGroup.query_action]</doc>
        <callback name="query_action">
          <source-position filename="gio/gactiongroup.h" line="90"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactiongroup.c"
                 line="770">`TRUE` if the action exists, else `FALSE`</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="734">a [type@Gio.ActionGroup]</doc>
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="735">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="enabled"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="736">if the action is presently enabled</doc>
              <type name="gboolean" c:type="gboolean*"/>
            </parameter>
            <parameter name="parameter_type"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="none"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="737">the parameter type, or `NULL` if none needed</doc>
              <type name="GLib.VariantType" c:type="const GVariantType**"/>
            </parameter>
            <parameter name="state_type"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="none"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="738">the state type, or `NULL` if stateless</doc>
              <type name="GLib.VariantType" c:type="const GVariantType**"/>
            </parameter>
            <parameter name="state_hint"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="739">the state hint, or `NULL` if none</doc>
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
            <parameter name="state"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gactiongroup.c"
                   line="740">the current state, or `NULL` if stateless</doc>
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ActionInterface"
            c:type="GActionInterface"
            glib:is-gtype-struct-for="Action"
            version="2.28">
      <doc xml:space="preserve"
           filename="gio/gaction.c"
           line="64">The virtual function table for [type@Gio.Action].</doc>
      <source-position filename="gio/gaction.h" line="59"/>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_name">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="66">the virtual function pointer for [method@Gio.Action.get_name]</doc>
        <callback name="get_name">
          <source-position filename="gio/gaction.h" line="47"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="228">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="224">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parameter_type">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="67">the virtual function pointer for [method@Gio.Action.get_parameter_type]</doc>
        <callback name="get_parameter_type">
          <source-position filename="gio/gaction.h" line="48"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="255">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="243">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_type">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="68">the virtual function pointer for [method@Gio.Action.get_state_type]</doc>
        <callback name="get_state_type">
          <source-position filename="gio/gaction.h" line="49"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="285">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="270">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_hint">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="69">the virtual function pointer for [method@Gio.Action.get_state_hint]</doc>
        <callback name="get_state_hint">
          <source-position filename="gio/gaction.h" line="50"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="321">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="300">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_enabled">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="70">the virtual function pointer for [method@Gio.Action.get_enabled]</doc>
        <callback name="get_enabled">
          <source-position filename="gio/gaction.h" line="52"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="343">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="336">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="71">the virtual function pointer for [method@Gio.Action.get_state]</doc>
        <callback name="get_state">
          <source-position filename="gio/gaction.h" line="53"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gaction.c"
                 line="209">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="198">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_state">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="72">the virtual function pointer for [method@Gio.Action.change_state]</doc>
        <callback name="change_state">
          <source-position filename="gio/gaction.h" line="55"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="160">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="161">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <doc xml:space="preserve"
             filename="gio/gaction.c"
             line="73">the virtual function pointer for [method@Gio.Action.activate].  Note that [type@Gio.Action] does not have an
           'activate' signal but that implementations of it may have one.</doc>
        <callback name="activate">
          <source-position filename="gio/gaction.h" line="57"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="358">a [type@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="parameter"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gaction.c"
                   line="359">the parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="ActionMap"
               c:symbol-prefix="action_map"
               c:type="GActionMap"
               version="2.32"
               glib:type-name="GActionMap"
               glib:get-type="g_action_map_get_type"
               glib:type-struct="ActionMapInterface">
      <doc xml:space="preserve"
           filename="gio/gactionmap.c"
           line="28">`GActionMap` is an interface for action containers.

The `GActionMap` interface is implemented by [iface@Gio.ActionGroup]
implementations that operate by containing a number of named
[iface@Gio.Action] instances, such as [class@Gio.SimpleActionGroup].

One useful application of this interface is to map the
names of actions from various action groups to unique,
prefixed names (e.g. by prepending "app." or "win.").
This is the motivation for the ‘Map’ part of the interface
name.</doc>
      <source-position filename="gio/gactionmap.h" line="55"/>
      <virtual-method name="add_action" invoker="add_action" version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="88">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <source-position filename="gio/gactionmap.h" line="51"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="90">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="91">a [iface@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_action"
                      invoker="lookup_action"
                      version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="67">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns `NULL`.</doc>
        <source-position filename="gio/gactionmap.h" line="49"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactionmap.c"
               line="76">a [iface@Gio.Action]</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="69">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="70">the name of an action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_action"
                      invoker="remove_action"
                      version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="109">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <source-position filename="gio/gactionmap.h" line="53"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="111">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="112">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_action"
              c:identifier="g_action_map_add_action"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="88">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <source-position filename="gio/gactionmap.h" line="84"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="90">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="91">a [iface@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_action_entries"
              c:identifier="g_action_map_add_action_entries"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="159">A convenience function for creating multiple [class@Gio.SimpleAction]
instances and adding them to a [iface@Gio.ActionMap].

Each action is constructed as per one [struct@Gio.ActionEntry].

```c
static void
activate_quit (GSimpleAction *simple,
               GVariant      *parameter,
               gpointer       user_data)
{
  exit (0);
}

static void
activate_print_string (GSimpleAction *simple,
                       GVariant      *parameter,
                       gpointer       user_data)
{
  g_print ("%s\n", g_variant_get_string (parameter, NULL));
}

static GActionGroup *
create_action_group (void)
{
  const GActionEntry entries[] = {
    { "quit",         activate_quit              },
    { "print-string", activate_print_string, "s" }
  };
  GSimpleActionGroup *group;

  group = g_simple_action_group_new ();
  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);

  return G_ACTION_GROUP (group);
}
```</doc>
        <source-position filename="gio/gactionmap.h" line="90"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="161">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="162">a pointer to
  the first item in an array of [struct@Gio.ActionEntry] structs</doc>
            <array length="1" zero-terminated="0" c:type="const GActionEntry*">
              <type name="ActionEntry"/>
            </array>
          </parameter>
          <parameter name="n_entries" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="164">the length of @entries, or -1 if @entries is `NULL`-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="165">the user data for signal connections</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_action"
              c:identifier="g_action_map_lookup_action"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="67">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns `NULL`.</doc>
        <source-position filename="gio/gactionmap.h" line="81"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gactionmap.c"
               line="76">a [iface@Gio.Action]</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="69">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="70">the name of an action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_action"
              c:identifier="g_action_map_remove_action"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="109">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <source-position filename="gio/gactionmap.h" line="87"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="111">an action map</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="112">the name of the action</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_action_entries"
              c:identifier="g_action_map_remove_action_entries"
              version="2.78">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="280">Remove actions from a [iface@Gio.ActionMap]. This is meant as the reverse of
[method@Gio.ActionMap.add_action_entries].


```c
static const GActionEntry entries[] = {
    { "quit",         activate_quit              },
    { "print-string", activate_print_string, "s" }
};

void
add_actions (GActionMap *map)
{
  g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
}

void
remove_actions (GActionMap *map)
{
  g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
}
```</doc>
        <source-position filename="gio/gactionmap.h" line="95"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="282">The [iface@Gio.ActionMap]</doc>
            <type name="ActionMap" c:type="GActionMap*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="283">a pointer to
  the first item in an array of [struct@Gio.ActionEntry] structs</doc>
            <array length="1" zero-terminated="0" c:type="const GActionEntry*">
              <type name="ActionEntry"/>
            </array>
          </parameter>
          <parameter name="n_entries" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="285">the length of @entries, or -1 if @entries is `NULL`-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ActionMapInterface"
            c:type="GActionMapInterface"
            glib:is-gtype-struct-for="ActionMap"
            version="2.32">
      <doc xml:space="preserve"
           filename="gio/gactionmap.c"
           line="46">The virtual function table for [iface@Gio.ActionMap].</doc>
      <source-position filename="gio/gactionmap.h" line="55"/>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="lookup_action">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="48">the virtual function pointer for
  [method@Gio.ActionMap.lookup_action]</doc>
        <callback name="lookup_action">
          <source-position filename="gio/gactionmap.h" line="49"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gactionmap.c"
                 line="76">a [iface@Gio.Action]</doc>
            <type name="Action" c:type="GAction*"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="69">an action map</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="70">the name of an action</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_action">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="50">the virtual function pointer for
  [method@Gio.ActionMap.add_action]</doc>
        <callback name="add_action">
          <source-position filename="gio/gactionmap.h" line="51"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="90">an action map</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="91">a [iface@Gio.Action]</doc>
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_action">
        <doc xml:space="preserve"
             filename="gio/gactionmap.c"
             line="52">the virtual function pointer for
  [method@Gio.ActionMap.remove_action]</doc>
        <callback name="remove_action">
          <source-position filename="gio/gactionmap.h" line="53"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="111">an action map</doc>
              <type name="ActionMap" c:type="GActionMap*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gactionmap.c"
                   line="112">the name of the action</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="AppInfo"
               c:symbol-prefix="app_info"
               c:type="GAppInfo"
               glib:type-name="GAppInfo"
               glib:get-type="g_app_info_get_type"
               glib:type-struct="AppInfoIface">
      <doc xml:space="preserve"
           filename="gio/gappinfo.c"
           line="48">Information about an installed application and methods to launch
it (with file arguments).

`GAppInfo` and `GAppLaunchContext` are used for describing and launching
applications installed on the system.

As of GLib 2.20, URIs will always be converted to POSIX paths
(using [method@Gio.File.get_path]) when using [method@Gio.AppInfo.launch]
even if the application requested an URI and not a POSIX path. For example
for a desktop-file based application with the following Exec key:

```
Exec=totem %U
```

and a single URI, `sftp://foo/file.avi`, then
`/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only work
if a set of suitable GIO extensions (such as GVfs 2.26 compiled with FUSE
support), is available and operational; if this is not the case, the URI
will be passed unmodified to the application. Some URIs, such as `mailto:`,
of course cannot be mapped to a POSIX path (in GVfs there’s no FUSE mount
for it); such URIs will be passed unmodified to the application.

Specifically for GVfs 2.26 and later, the POSIX URI will be mapped
back to the GIO URI in the [iface@Gio.File] constructors (since GVfs
implements the GVfs extension point). As such, if the application
needs to examine the URI, it needs to use [method@Gio.File.get_uri]
or similar on [iface@Gio.File]. In other words, an application cannot
assume that the URI passed to e.g. [func@Gio.File.new_for_commandline_arg]
is equal to the result of [method@Gio.File.get_uri]. The following snippet
illustrates this:

```c
GFile *f;
char *uri;

file = g_file_new_for_commandline_arg (uri_from_commandline);

uri = g_file_get_uri (file);
strcmp (uri, uri_from_commandline) == 0;
g_free (uri);

if (g_file_has_uri_scheme (file, "cdda"))
  {
    // do something special with uri
  }
g_object_unref (file);
```

This code will work when both `cdda://sr0/Track 1.wav` and
`/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
application. It should be noted that it’s generally not safe
for applications to rely on the format of a particular URIs.
Different launcher applications (e.g. file managers) may have
different ideas of what a given URI means.</doc>
      <source-position filename="gio/gappinfo.h" line="155"/>
      <function name="create_from_commandline"
                c:identifier="g_app_info_create_from_commandline"
                throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="120">Creates a new [iface@Gio.AppInfo] from the given information.

Note that for @commandline, the quoting rules of the `Exec` key of the
[freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
are applied. For example, if the @commandline contains
percent-encoded URIs, the percent-character must be doubled in order to prevent it from
being swallowed by `Exec` key unquoting. See
[the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
for exact quoting rules.</doc>
        <source-position filename="gio/gappinfo.h" line="160"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="138">new [iface@Gio.AppInfo] for given command.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="commandline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="122">the command line to use</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="application_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="123">the application name, or `NULL` to use @commandline</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="124">flags that can specify details of the created [iface@Gio.AppInfo]</doc>
            <type name="AppInfoCreateFlags" c:type="GAppInfoCreateFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_all" c:identifier="g_app_info_get_all">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="410">Gets a list of all of the applications currently registered
on this system.

For desktop files, this includes applications that have
[`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
set or are excluded from display by means of
[`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
See [method@Gio.AppInfo.should_show].

The returned list does not include applications which have the
[`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
set.</doc>
        <source-position filename="gio/gappinfo.h" line="244"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="427">a newly allocated
  list of references to [iface@Gio.AppInfo]s.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
      </function>
      <function name="get_all_for_type"
                c:identifier="g_app_info_get_all_for_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="482">Gets a list of all [iface@Gio.AppInfo]s for a given content type,
including the recommended and fallback [iface@Gio.AppInfo]s. See
[func@Gio.AppInfo.get_recommended_for_type] and
[func@Gio.AppInfo.get_fallback_for_type].</doc>
        <source-position filename="gio/gappinfo.h" line="246"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="491">list of
  [iface@Gio.AppInfo]s for given @content_type.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="484">the content type to find a [iface@Gio.AppInfo] for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_type"
                c:identifier="g_app_info_get_default_for_type"
                glib:async-func="get_default_for_type_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="520">Gets the default [iface@Gio.AppInfo] for a given content type.</doc>
        <source-position filename="gio/gappinfo.h" line="255"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="528">[iface@Gio.AppInfo] for given
  @content_type or `NULL` on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="522">the content type to find a [iface@Gio.AppInfo] for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="must_support_uris" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="523">if `TRUE`, the [iface@Gio.AppInfo] is expected to
  support URIs</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_type_async"
                c:identifier="g_app_info_get_default_for_type_async"
                version="2.74"
                glib:finish-func="get_default_for_type_finish"
                glib:sync-func="get_default_for_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1002">Asynchronously gets the default [iface@Gio.AppInfo] for a given content
type.</doc>
        <source-position filename="gio/gappinfo.h" line="258"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1004">the content type to find a [iface@Gio.AppInfo] for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="must_support_uris" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1005">if `TRUE`, the [iface@Gio.AppInfo] is expected to
  support URIs</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1007">a [class@Gio.Cancellable]</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1008">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1010">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_type_finish"
                c:identifier="g_app_info_get_default_for_type_finish"
                version="2.74"
                throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1125">Finishes a default [iface@Gio.AppInfo] lookup started by
[func@Gio.AppInfo.get_default_for_type_async].

If no #[iface@Gio.AppInfo] is found, then @error will be set to
[error@Gio.IOErrorEnum.NOT_FOUND].</doc>
        <source-position filename="gio/gappinfo.h" line="264"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1135">[iface@Gio.AppInfo] for given @content_type or
  `NULL` on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1127">the async result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_uri_scheme"
                c:identifier="g_app_info_get_default_for_uri_scheme"
                glib:async-func="get_default_for_uri_scheme_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="540">Gets the default application for handling URIs with the given URI scheme.

A URI scheme is the initial part of the URI, up to but not including the `:`.
For example, `http`, `ftp` or `sip`.</doc>
        <source-position filename="gio/gappinfo.h" line="267"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="549">[iface@Gio.AppInfo] for given
  @uri_scheme or `NULL` on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="542">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_uri_scheme_async"
                c:identifier="g_app_info_get_default_for_uri_scheme_async"
                version="2.74"
                glib:finish-func="get_default_for_uri_scheme_finish"
                glib:sync-func="get_default_for_uri_scheme">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1064">Asynchronously gets the default application for handling URIs with
the given URI scheme. A URI scheme is the initial part
of the URI, up to but not including the `:`, e.g. `http`,
`ftp` or `sip`.</doc>
        <source-position filename="gio/gappinfo.h" line="270"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1066">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1067">a [class@Gio.Cancellable]</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1068">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1070">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default_for_uri_scheme_finish"
                c:identifier="g_app_info_get_default_for_uri_scheme_finish"
                version="2.74"
                throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1098">Finishes a default [iface@Gio.AppInfo] lookup started by
[func@Gio.AppInfo.get_default_for_uri_scheme_async].

If no [iface@Gio.AppInfo] is found, then @error will be set to
[error@Gio.IOErrorEnum.NOT_FOUND].</doc>
        <source-position filename="gio/gappinfo.h" line="275"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1108">[iface@Gio.AppInfo] for given @uri_scheme or
  `NULL` on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1100">the async result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_fallback_for_type"
                c:identifier="g_app_info_get_fallback_for_type"
                version="2.28">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="461">Gets a list of fallback [iface@Gio.AppInfo]s for a given content type, i.e.
those applications which claim to support the given content type by MIME
type subclassing and not directly.</doc>
        <source-position filename="gio/gappinfo.h" line="250"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="469">list of [iface@Gio.AppInfo]s
    for given @content_type or `NULL` on error.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="463">the content type to find a [iface@Gio.AppInfo] for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_recommended_for_type"
                c:identifier="g_app_info_get_recommended_for_type"
                version="2.28">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="436">Gets a list of recommended [iface@Gio.AppInfo]s for a given content type,
i.e. those applications which claim to support the given content type
exactly, and not by MIME type subclassing.

Note that the first application of the list is the last used one, i.e.
the last one for which [method@Gio.AppInfo.set_as_last_used_for_type] has
been called.</doc>
        <source-position filename="gio/gappinfo.h" line="248"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="448">list of
  [iface@Gio.AppInfo]s for given @content_type or `NULL` on error.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="AppInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="438">the content type to find a [iface@Gio.AppInfo] for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri"
                c:identifier="g_app_info_launch_default_for_uri"
                throws="1"
                glib:async-func="launch_default_for_uri_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1152">Utility function that launches the default application registered to handle
the specified uri. Synchronous I/O is done on the uri to detect the type of
the file if required.

The D-Bus–activated applications don’t have to be started if your application
terminates too soon after this function. To prevent this, use
[func@Gio.AppInfo.launch_default_for_uri_async] instead.</doc>
        <source-position filename="gio/gappinfo.h" line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1165">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1154">the uri to show</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1155">optional launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri_async"
                c:identifier="g_app_info_launch_default_for_uri_async"
                version="2.50"
                glib:finish-func="launch_default_for_uri_finish"
                glib:sync-func="launch_default_for_uri">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1417">Async version of [func@Gio.AppInfo.launch_default_for_uri].

This version is useful if you are interested in receiving error information
in the case where the application is sandboxed and the portal may present an
application chooser dialog to the user.

This is also useful if you want to be sure that the D-Bus–activated
applications are really started before termination and if you are interested
in receiving error information from their activation.</doc>
        <source-position filename="gio/gappinfo.h" line="284"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1419">the uri to show</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1420">optional launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1421">a [class@Gio.Cancellable]</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1422">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1424">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="launch_default_for_uri_finish"
                c:identifier="g_app_info_launch_default_for_uri_finish"
                version="2.50"
                throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1479">Finishes an asynchronous launch-default-for-uri operation.</doc>
        <source-position filename="gio/gappinfo.h" line="290"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1485">`TRUE` if the launch was successful, `FALSE` if @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1481">the async result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="reset_type_associations"
                c:identifier="g_app_info_reset_type_associations"
                version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="502">Removes all changes to the type associations done by
[method@Gio.AppInfo.set_as_default_for_type],
[method@Gio.AppInfo.set_as_default_for_extension],
[method@Gio.AppInfo.add_supports_type] or
[method@Gio.AppInfo.remove_supports_type].</doc>
        <source-position filename="gio/gappinfo.h" line="253"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="504">a content type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="add_supports_type"
                      invoker="add_supports_type"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="591">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <source-position filename="gio/gappinfo.h" line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="599">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="593">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="594">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_delete" invoker="can_delete" version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1498">Obtains the information whether the [iface@Gio.AppInfo] can be deleted.
See [method@Gio.AppInfo.delete].</doc>
        <source-position filename="gio/gappinfo.h" line="138"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1505">`TRUE` if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1500">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_remove_supports_type"
                      invoker="can_remove_supports_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="624">Checks if a supported content type can be removed from an application.</doc>
        <source-position filename="gio/gappinfo.h" line="134"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="630">`TRUE` if it is possible to remove supported content types from a
  given @appinfo, `FALSE` if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="626">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_delete" invoker="delete" version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1525">Tries to delete a [iface@Gio.AppInfo].

On some platforms, there may be a difference between user-defined
[iface@Gio.AppInfo]s which can be deleted, and system-wide ones which cannot.
See [method@Gio.AppInfo.can_delete].</doc>
        <source-position filename="gio/gappinfo.h" line="139"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1535">`TRUE` if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1527">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup" invoker="dup">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="153">Creates a duplicate of a [iface@Gio.AppInfo].</doc>
        <source-position filename="gio/gappinfo.h" line="104"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="159">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="155">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="173">Checks if two [iface@Gio.AppInfo]s are equal.

Note that the check *may not* compare each individual field, and only does
an identity check. In case detecting changes in the contents is needed,
program code must additionally compare relevant fields.</doc>
        <source-position filename="gio/gappinfo.h" line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="184">`TRUE` if @appinfo1 is equal to @appinfo2. `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="175">the first [iface@Gio.AppInfo].</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="176">the second [iface@Gio.AppInfo].</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_commandline"
                      invoker="get_commandline"
                      version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="322">Gets the commandline with which the application will be
started.</doc>
        <source-position filename="gio/gappinfo.h" line="140"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="329">a string containing the @appinfo’s
  commandline, or `NULL` if this information is not available</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="324">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_description" invoker="get_description">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="275">Gets a human-readable description of an installed application.</doc>
        <source-position filename="gio/gappinfo.h" line="109"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="281">a string containing a description of the
application @appinfo, or `NULL` if none.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="277">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_display_name"
                      invoker="get_display_name"
                      version="2.24">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="248">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.</doc>
        <source-position filename="gio/gappinfo.h" line="141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="255">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="250">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_executable" invoker="get_executable">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="296">Gets the executable’s name for the installed application.

This is intended to be used for debugging or labelling what program is going
to be run. To launch the executable, use [method@Gio.AppInfo.launch] and related
functions, rather than spawning the return value from this function.</doc>
        <source-position filename="gio/gappinfo.h" line="110"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="306">a string containing the @appinfo’s application
binaries name</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="298">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="713">Gets the icon for the application.</doc>
        <source-position filename="gio/gappinfo.h" line="111"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="719">the default [iface@Gio.Icon] for
  @appinfo or `NULL` if there is no default icon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="715">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_id" invoker="get_id">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="203">Gets the ID of an application. An id is a string that identifies the
application. The exact format of the id is platform dependent. For instance,
on Unix this is the desktop file id from the xdg menu specification.

Note that the returned ID may be `NULL`, depending on how the @appinfo has
been constructed.</doc>
        <source-position filename="gio/gappinfo.h" line="107"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="214">a string containing the application’s ID.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="205">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="228">Gets the installed name of the application.</doc>
        <source-position filename="gio/gappinfo.h" line="108"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="234">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="230">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_supported_types"
                      invoker="get_supported_types"
                      version="2.34">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="680">Retrieves the list of content types that @app_info claims to support.
If this information is not provided by the environment, this function
will return `NULL`.

This function does not take in consideration associations added with
[method@Gio.AppInfo.add_supports_type], but only those exported directly by
the application.</doc>
        <source-position filename="gio/gappinfo.h" line="145"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="692">
  a list of content types.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="682">an app info that can handle files</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch" invoker="launch" throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="735">Launches the application. Passes @files to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a `NULL` @files list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.

Some URIs can be changed when passed through a GFile (for instance
unsupported URIs with strange formats like mailto:), so if you have
a textual URI you want to pass in as argument, consider using
[method@Gio.AppInfo.launch_uris] instead.

The launched application inherits the environment of the launching
process, but it can be modified with [method@Gio.AppLaunchContext.setenv]
and [method@Gio.AppLaunchContext.unsetenv].

On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
environment variable with the path of the launched desktop file and
`GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
should it be inherited by further processes. The `DISPLAY`,
`XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
variables are also set, based on information provided in @context.</doc>
        <source-position filename="gio/gappinfo.h" line="112"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="769">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="737">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="files"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="738">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="739">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_uris"
                      invoker="launch_uris"
                      throws="1"
                      glib:async-func="launch_uris_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="829">Launches the application. This passes the @uris to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly. If the application only supports
one URI per invocation as part of their command-line, multiple instances
of the application will be spawned.

To launch the application without arguments pass a `NULL` @uris list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <source-position filename="gio/gappinfo.h" line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="848">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="831">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="832">a list of URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="833">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_uris_async"
                      invoker="launch_uris_async"
                      version="2.60"
                      glib:finish-func="launch_uris_finish"
                      glib:sync-func="launch_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="865">Async version of [method@Gio.AppInfo.launch_uris].

The @callback is invoked immediately after the application launch, but it
waits for activation in case of D-Bus–activated applications and also provides
extended error information for sandboxed applications, see notes for
[func@Gio.AppInfo.launch_default_for_uri_async].</doc>
        <source-position filename="gio/gappinfo.h" line="146"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="867">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="868">a list of URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="869">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="870">a [class@Gio.Cancellable]</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="871">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="873">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_uris_finish"
                      invoker="launch_uris_finish"
                      version="2.60"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="915">Finishes a [method@Gio.AppInfo.launch_uris_async] operation.</doc>
        <source-position filename="gio/gappinfo.h" line="152"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="922">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="917">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="918">the async result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_supports_type"
                      invoker="remove_supports_type"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="649">Removes a supported type from an application, if possible.</doc>
        <source-position filename="gio/gappinfo.h" line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="656">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="651">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="652">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_extension"
                      invoker="set_as_default_for_extension"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="560">Sets the application as the default handler for the given file extension.</doc>
        <source-position filename="gio/gappinfo.h" line="128"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="568">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="562">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="563">a string containing the file extension (without
  the dot).</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_type"
                      invoker="set_as_default_for_type"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="349">Sets the application as the default handler for a given type.</doc>
        <source-position filename="gio/gappinfo.h" line="125"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="356">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="351">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="352">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_last_used_for_type"
                      invoker="set_as_last_used_for_type"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="378">Sets the application as the last used application for a given type. This
will make the application appear as first in the list returned by
[func@Gio.AppInfo.get_recommended_for_type], regardless of the default
application for that content type.</doc>
        <source-position filename="gio/gappinfo.h" line="142"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="388">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="380">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="381">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="should_show" invoker="should_show">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="946">Checks if the application info should be shown in menus that
list available applications.</doc>
        <source-position filename="gio/gappinfo.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="953">`TRUE` if the @appinfo should be shown, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="948">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_files" invoker="supports_files">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="808">Checks if the application accepts files as arguments.</doc>
        <source-position filename="gio/gappinfo.h" line="117"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="814">`TRUE` if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="810">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_uris" invoker="supports_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="787">Checks if the application supports reading files and directories from URIs.</doc>
        <source-position filename="gio/gappinfo.h" line="116"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="793">`TRUE` if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="789">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_supports_type"
              c:identifier="g_app_info_add_supports_type"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="591">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <source-position filename="gio/gappinfo.h" line="221"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="599">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="593">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="594">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_delete"
              c:identifier="g_app_info_can_delete"
              version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1498">Obtains the information whether the [iface@Gio.AppInfo] can be deleted.
See [method@Gio.AppInfo.delete].</doc>
        <source-position filename="gio/gappinfo.h" line="234"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1505">`TRUE` if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1500">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="can_remove_supports_type"
              c:identifier="g_app_info_can_remove_supports_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="624">Checks if a supported content type can be removed from an application.</doc>
        <source-position filename="gio/gappinfo.h" line="225"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="630">`TRUE` if it is possible to remove supported content types from a
  given @appinfo, `FALSE` if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="626">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="g_app_info_delete" version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1525">Tries to delete a [iface@Gio.AppInfo].

On some platforms, there may be a difference between user-defined
[iface@Gio.AppInfo]s which can be deleted, and system-wide ones which cannot.
See [method@Gio.AppInfo.can_delete].</doc>
        <source-position filename="gio/gappinfo.h" line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1535">`TRUE` if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1527">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_app_info_dup">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="153">Creates a duplicate of a [iface@Gio.AppInfo].</doc>
        <source-position filename="gio/gappinfo.h" line="165"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="159">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="155">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_app_info_equal">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="173">Checks if two [iface@Gio.AppInfo]s are equal.

Note that the check *may not* compare each individual field, and only does
an identity check. In case detecting changes in the contents is needed,
program code must additionally compare relevant fields.</doc>
        <source-position filename="gio/gappinfo.h" line="167"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="184">`TRUE` if @appinfo1 is equal to @appinfo2. `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="175">the first [iface@Gio.AppInfo].</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="176">the second [iface@Gio.AppInfo].</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_commandline"
              c:identifier="g_app_info_get_commandline"
              version="2.20">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="322">Gets the commandline with which the application will be
started.</doc>
        <source-position filename="gio/gappinfo.h" line="180"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="329">a string containing the @appinfo’s
  commandline, or `NULL` if this information is not available</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="324">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="g_app_info_get_description">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="275">Gets a human-readable description of an installed application.</doc>
        <source-position filename="gio/gappinfo.h" line="176"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="281">a string containing a description of the
application @appinfo, or `NULL` if none.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="277">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="g_app_info_get_display_name"
              version="2.24">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="248">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.</doc>
        <source-position filename="gio/gappinfo.h" line="174"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="255">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="250">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_executable" c:identifier="g_app_info_get_executable">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="296">Gets the executable’s name for the installed application.

This is intended to be used for debugging or labelling what program is going
to be run. To launch the executable, use [method@Gio.AppInfo.launch] and related
functions, rather than spawning the return value from this function.</doc>
        <source-position filename="gio/gappinfo.h" line="178"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="306">a string containing the @appinfo’s application
binaries name</doc>
          <type name="filename" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="298">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_app_info_get_icon">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="713">Gets the icon for the application.</doc>
        <source-position filename="gio/gappinfo.h" line="182"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="719">the default [iface@Gio.Icon] for
  @appinfo or `NULL` if there is no default icon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="715">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="g_app_info_get_id">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="203">Gets the ID of an application. An id is a string that identifies the
application. The exact format of the id is platform dependent. For instance,
on Unix this is the desktop file id from the xdg menu specification.

Note that the returned ID may be `NULL`, depending on how the @appinfo has
been constructed.</doc>
        <source-position filename="gio/gappinfo.h" line="170"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="214">a string containing the application’s ID.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="205">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_app_info_get_name">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="228">Gets the installed name of the application.</doc>
        <source-position filename="gio/gappinfo.h" line="172"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="234">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="230">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_supported_types"
              c:identifier="g_app_info_get_supported_types"
              version="2.34">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="680">Retrieves the list of content types that @app_info claims to support.
If this information is not provided by the environment, this function
will return `NULL`.

This function does not take in consideration associations added with
[method@Gio.AppInfo.add_supports_type], but only those exported directly by
the application.</doc>
        <source-position filename="gio/gappinfo.h" line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="692">
  a list of content types.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="682">an app info that can handle files</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="launch" c:identifier="g_app_info_launch" throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="735">Launches the application. Passes @files to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.

To launch the application without arguments pass a `NULL` @files list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.

Some URIs can be changed when passed through a GFile (for instance
unsupported URIs with strange formats like mailto:), so if you have
a textual URI you want to pass in as argument, consider using
[method@Gio.AppInfo.launch_uris] instead.

The launched application inherits the environment of the launching
process, but it can be modified with [method@Gio.AppLaunchContext.setenv]
and [method@Gio.AppLaunchContext.unsetenv].

On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
environment variable with the path of the launched desktop file and
`GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
should it be inherited by further processes. The `DISPLAY`,
`XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
variables are also set, based on information provided in @context.</doc>
        <source-position filename="gio/gappinfo.h" line="184"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="769">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="737">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="files"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="738">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="739">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris"
              c:identifier="g_app_info_launch_uris"
              throws="1"
              glib:async-func="launch_uris_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="829">Launches the application. This passes the @uris to the launched application
as arguments, using the optional @context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly. If the application only supports
one URI per invocation as part of their command-line, multiple instances
of the application will be spawned.

To launch the application without arguments pass a `NULL` @uris list.

Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <source-position filename="gio/gappinfo.h" line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="848">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="831">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="832">a list of URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="833">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris_async"
              c:identifier="g_app_info_launch_uris_async"
              version="2.60"
              glib:finish-func="launch_uris_finish"
              glib:sync-func="launch_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="865">Async version of [method@Gio.AppInfo.launch_uris].

The @callback is invoked immediately after the application launch, but it
waits for activation in case of D-Bus–activated applications and also provides
extended error information for sandboxed applications, see notes for
[func@Gio.AppInfo.launch_default_for_uri_async].</doc>
        <source-position filename="gio/gappinfo.h" line="198"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="867">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="uris"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="868">a list of URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="869">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="870">a [class@Gio.Cancellable]</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="871">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="873">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris_finish"
              c:identifier="g_app_info_launch_uris_finish"
              version="2.60"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="915">Finishes a [method@Gio.AppInfo.launch_uris_async] operation.</doc>
        <source-position filename="gio/gappinfo.h" line="205"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="922">`TRUE` on successful launch, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="917">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="918">the async result</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_supports_type"
              c:identifier="g_app_info_remove_supports_type"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="649">Removes a supported type from an application, if possible.</doc>
        <source-position filename="gio/gappinfo.h" line="227"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="656">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="651">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="652">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_extension"
              c:identifier="g_app_info_set_as_default_for_extension"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="560">Sets the application as the default handler for the given file extension.</doc>
        <source-position filename="gio/gappinfo.h" line="217"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="568">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="562">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="563">a string containing the file extension (without
  the dot).</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_type"
              c:identifier="g_app_info_set_as_default_for_type"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="349">Sets the application as the default handler for a given type.</doc>
        <source-position filename="gio/gappinfo.h" line="213"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="356">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="351">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="352">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_last_used_for_type"
              c:identifier="g_app_info_set_as_last_used_for_type"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="378">Sets the application as the last used application for a given type. This
will make the application appear as first in the list returned by
[func@Gio.AppInfo.get_recommended_for_type], regardless of the default
application for that content type.</doc>
        <source-position filename="gio/gappinfo.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="388">`TRUE` on success, `FALSE` on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="380">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="381">the content type.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="should_show" c:identifier="g_app_info_should_show">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="946">Checks if the application info should be shown in menus that
list available applications.</doc>
        <source-position filename="gio/gappinfo.h" line="210"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="953">`TRUE` if the @appinfo should be shown, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="948">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_files" c:identifier="g_app_info_supports_files">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="808">Checks if the application accepts files as arguments.</doc>
        <source-position filename="gio/gappinfo.h" line="191"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="814">`TRUE` if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="810">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="supports_uris" c:identifier="g_app_info_supports_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="787">Checks if the application supports reading files and directories from URIs.</doc>
        <source-position filename="gio/gappinfo.h" line="189"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="793">`TRUE` if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="appinfo" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="789">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <bitfield name="AppInfoCreateFlags"
              glib:type-name="GAppInfoCreateFlags"
              glib:get-type="g_app_info_create_flags_get_type"
              c:type="GAppInfoCreateFlags">
      <doc xml:space="preserve"
           filename="gio/gioenums.h"
           line="36">Flags used when creating a #GAppInfo.</doc>
      <member name="none"
              value="0"
              c:identifier="G_APP_INFO_CREATE_NONE"
              glib:nick="none"
              glib:name="G_APP_INFO_CREATE_NONE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="38">No flags.</doc>
      </member>
      <member name="needs_terminal"
              value="1"
              c:identifier="G_APP_INFO_CREATE_NEEDS_TERMINAL"
              glib:nick="needs-terminal"
              glib:name="G_APP_INFO_CREATE_NEEDS_TERMINAL">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="39">Application opens in a terminal window.</doc>
      </member>
      <member name="supports_uris"
              value="2"
              c:identifier="G_APP_INFO_CREATE_SUPPORTS_URIS"
              glib:nick="supports-uris"
              glib:name="G_APP_INFO_CREATE_SUPPORTS_URIS">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="40">Application supports URI arguments.</doc>
      </member>
      <member name="supports_startup_notification"
              value="4"
              c:identifier="G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION"
              glib:nick="supports-startup-notification"
              glib:name="G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="41">Application supports startup notification. Since 2.26</doc>
      </member>
    </bitfield>
    <record name="AppInfoIface"
            c:type="GAppInfoIface"
            glib:is-gtype-struct-for="AppInfo">
      <doc xml:space="preserve"
           filename="gio/gappinfo.h"
           line="49">Application Information interface, for operating system portability.</doc>
      <source-position filename="gio/gappinfo.h" line="155"/>
      <field name="g_iface">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="51">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="dup">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="52">Copies a [iface@Gio.AppInfo].</doc>
        <callback name="dup">
          <source-position filename="gio/gappinfo.h" line="104"/>
          <return-value transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="159">a duplicate of @appinfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="155">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="53">Checks two [iface@Gio.AppInfo]s for equality.</doc>
        <callback name="equal">
          <source-position filename="gio/gappinfo.h" line="105"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="184">`TRUE` if @appinfo1 is equal to @appinfo2. `FALSE` otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo1" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="175">the first [iface@Gio.AppInfo].</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="appinfo2" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="176">the second [iface@Gio.AppInfo].</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_id">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="54">Gets a string identifier for a [iface@Gio.AppInfo].</doc>
        <callback name="get_id">
          <source-position filename="gio/gappinfo.h" line="107"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="214">a string containing the application’s ID.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="205">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="55">Gets the name of the application for a [iface@Gio.AppInfo].</doc>
        <callback name="get_name">
          <source-position filename="gio/gappinfo.h" line="108"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="234">the name of the application for @appinfo.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="230">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_description">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="56">Gets a short description for the application described by
  the [iface@Gio.AppInfo].</doc>
        <callback name="get_description">
          <source-position filename="gio/gappinfo.h" line="109"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="281">a string containing a description of the
application @appinfo, or `NULL` if none.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="277">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_executable">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="58">Gets the executable name for the [iface@Gio.AppInfo].</doc>
        <callback name="get_executable">
          <source-position filename="gio/gappinfo.h" line="110"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="306">a string containing the @appinfo’s application
binaries name</doc>
            <type name="filename" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="298">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="59">Gets the [iface@Gio.Icon] for the [iface@Gio.AppInfo].</doc>
        <callback name="get_icon">
          <source-position filename="gio/gappinfo.h" line="111"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="719">the default [iface@Gio.Icon] for
  @appinfo or `NULL` if there is no default icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="715">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="60">Launches an application specified by the [iface@Gio.AppInfo].</doc>
        <callback name="launch" throws="1">
          <source-position filename="gio/gappinfo.h" line="112"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="769">`TRUE` on successful launch, `FALSE` otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="737">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="738">a list of [iface@Gio.File] objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
            <parameter name="context"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="739">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="61">Indicates whether the application specified supports
  launching URIs.</doc>
        <callback name="supports_uris">
          <source-position filename="gio/gappinfo.h" line="116"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="793">`TRUE` if the @appinfo supports URIs.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="789">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_files">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="63">Indicates whether the application specified accepts
  filename arguments.</doc>
        <callback name="supports_files">
          <source-position filename="gio/gappinfo.h" line="117"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="814">`TRUE` if the @appinfo supports files.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="810">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_uris">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="65">Launches an application with a list of URIs.</doc>
        <callback name="launch_uris" throws="1">
          <source-position filename="gio/gappinfo.h" line="118"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="848">`TRUE` on successful launch, `FALSE` otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="831">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="uris"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="832">a list of URIs to launch.</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="utf8"/>
              </type>
            </parameter>
            <parameter name="context"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="833">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="should_show">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="66">Returns whether an application should be shown (e.g. when
  getting a list of installed applications).
  [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).</doc>
        <callback name="should_show">
          <source-position filename="gio/gappinfo.h" line="122"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="953">`TRUE` if the @appinfo should be shown, `FALSE` otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="948">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="69">Sets an application as default for a given content
  type.</doc>
        <callback name="set_as_default_for_type" throws="1">
          <source-position filename="gio/gappinfo.h" line="125"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="356">`TRUE` on success, `FALSE` on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="351">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="352">the content type.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_extension">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="71">Sets an application as default for a given
  file extension.</doc>
        <callback name="set_as_default_for_extension" throws="1">
          <source-position filename="gio/gappinfo.h" line="128"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="568">`TRUE` on success, `FALSE` on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="562">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="563">a string containing the file extension (without
  the dot).</doc>
              <type name="filename" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_supports_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="73">Adds to the [iface@Gio.AppInfo] information about
  supported file types.</doc>
        <callback name="add_supports_type" throws="1">
          <source-position filename="gio/gappinfo.h" line="131"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="599">`TRUE` on success, `FALSE` on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="593">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="594">a string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_remove_supports_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="75">Checks for support for removing supported file
  types from a [iface@Gio.AppInfo].</doc>
        <callback name="can_remove_supports_type">
          <source-position filename="gio/gappinfo.h" line="134"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="630">`TRUE` if it is possible to remove supported content types from a
  given @appinfo, `FALSE` if not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="626">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_supports_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="77">Removes a supported application type from a
  [iface@Gio.AppInfo].</doc>
        <callback name="remove_supports_type" throws="1">
          <source-position filename="gio/gappinfo.h" line="135"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="656">`TRUE` on success, `FALSE` on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="651">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="652">a string.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_delete">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="79">Checks if a [iface@Gio.AppInfo] can be deleted. (Since 2.20)</doc>
        <callback name="can_delete">
          <source-position filename="gio/gappinfo.h" line="138"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1505">`TRUE` if @appinfo can be deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1500">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_delete">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="80">Deletes a [iface@Gio.AppInfo]. (Since 2.20)</doc>
        <callback name="do_delete">
          <source-position filename="gio/gappinfo.h" line="139"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1535">`TRUE` if @appinfo has been deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1527">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_commandline">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="81">Gets the commandline for the [iface@Gio.AppInfo].
  (Since 2.20)</doc>
        <callback name="get_commandline">
          <source-position filename="gio/gappinfo.h" line="140"/>
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="329">a string containing the @appinfo’s
  commandline, or `NULL` if this information is not available</doc>
            <type name="filename" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="324">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_display_name">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="83">Gets the display name for the [iface@Gio.AppInfo].
  (Since 2.24)</doc>
        <callback name="get_display_name">
          <source-position filename="gio/gappinfo.h" line="141"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="255">the display name of the application for @appinfo, or the name if
no display name is available.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="250">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_last_used_for_type">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="85">Sets the application as the last used. See
  [method@Gio.AppInfo.set_as_last_used_for_type].</doc>
        <callback name="set_as_last_used_for_type" throws="1">
          <source-position filename="gio/gappinfo.h" line="142"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="388">`TRUE` on success, `FALSE` on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="380">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="381">the content type.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_supported_types">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="87">Retrieves the list of content types that @app_info
  claims to support.</doc>
        <callback name="get_supported_types">
          <source-position filename="gio/gappinfo.h" line="145"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="692">
  a list of content types.</doc>
            <array c:type="const char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="682">an app info that can handle files</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_uris_async">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="89">Asynchronously launches an application with a list of
  URIs. (Since: 2.60)</doc>
        <callback name="launch_uris_async">
          <source-position filename="gio/gappinfo.h" line="146"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="867">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="uris"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="868">a list of URIs to launch.</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="utf8"/>
              </type>
            </parameter>
            <parameter name="context"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="869">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="870">a [class@Gio.Cancellable]</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="5">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="871">a [type@Gio.AsyncReadyCallback] to call
  when the request is done</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="5">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="873">data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_uris_finish">
        <doc xml:space="preserve"
             filename="gio/gappinfo.h"
             line="91">Finishes an operation started with @launch_uris_async.
  (Since: 2.60)</doc>
        <callback name="launch_uris_finish" throws="1">
          <source-position filename="gio/gappinfo.h" line="152"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="922">`TRUE` on successful launch, `FALSE` otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="917">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="918">the async result</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="AppInfoMonitor"
           c:symbol-prefix="app_info_monitor"
           c:type="GAppInfoMonitor"
           version="2.40"
           parent="GObject.Object"
           glib:type-name="GAppInfoMonitor"
           glib:get-type="g_app_info_monitor_get_type">
      <doc xml:space="preserve"
           filename="gio/gappinfo.c"
           line="1881">`GAppInfoMonitor` monitors application information for changes.

`GAppInfoMonitor` is a very simple object used for monitoring the app
info database for changes (newly installed or removed applications).

Call [func@Gio.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
to the [signal@Gio.AppInfoMonitor::changed] signal. The signal will be emitted once when
the app info database changes, and will not be emitted again until after the
next call to [func@Gio.AppInfo.get_all] or another `g_app_info_*()` function.
This is because monitoring the app info database for changes is expensive.

The following functions will re-arm the [signal@Gio.AppInfoMonitor::changed]
signal so it can be emitted again:

 - [func@Gio.AppInfo.get_all]
 - [func@Gio.AppInfo.get_all_for_type]
 - [func@Gio.AppInfo.get_default_for_type]
 - [func@Gio.AppInfo.get_fallback_for_type]
 - [func@Gio.AppInfo.get_recommended_for_type]
 - [`g_desktop_app_info_get_implementations()`](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
 - [`g_desktop_app_info_new()`](../gio-unix/ctor.DesktopAppInfo.new.html)
 - [`g_desktop_app_info_new_from_filename()`](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
 - [`g_desktop_app_info_new_from_keyfile()`](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
 - [`g_desktop_app_info_search()`](../gio-unix/type_func.DesktopAppInfo.search.html)

The latter functions are available if using
[`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
`gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).

In the usual case, applications should try to make note of the change
(doing things like invalidating caches) but not act on it. In
particular, applications should avoid making calls to `GAppInfo` APIs
in response to the change signal, deferring these until the time that
the updated data is actually required. The exception to this case is when
application information is actually being displayed on the screen
(for example, during a search or when the list of all applications is shown).
The reason for this is that changes to the list of installed applications
often come in groups (like during system updates) and rescanning the list
on every change is pointless and expensive.</doc>
      <function name="get"
                c:identifier="g_app_info_monitor_get"
                version="2.40">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1979">Gets the #GAppInfoMonitor for the current thread-default main
context.

The #GAppInfoMonitor will emit a “changed” signal in the
thread-default main context whenever the list of installed
applications (as reported by g_app_info_get_all()) may have changed.

The #GAppInfoMonitor::changed signal will only be emitted once until
g_app_info_get_all() (or another `g_app_info_*()` function) is called. Doing
so will re-arm the signal ready to notify about the next change.

You must only call g_object_unref() on the return value from under
the same main context as you created it.</doc>
        <source-position filename="gio/gappinfo.h" line="373"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1996">a reference to a #GAppInfoMonitor</doc>
          <type name="AppInfoMonitor" c:type="GAppInfoMonitor*"/>
        </return-value>
      </function>
      <glib:signal name="changed" when="first" version="2.40">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1965">Signal emitted when the app info database changes, when applications are
installed or removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <class name="AppLaunchContext"
           c:symbol-prefix="app_launch_context"
           c:type="GAppLaunchContext"
           parent="GObject.Object"
           glib:type-name="GAppLaunchContext"
           glib:get-type="g_app_launch_context_get_type"
           glib:type-struct="AppLaunchContextClass">
      <doc xml:space="preserve"
           filename="gio/gappinfo.h"
           line="294">Integrating the launch with the launching application. This is used to
handle for instance startup notification and launching the new application
on the same screen as the launching window.</doc>
      <source-position filename="gio/gappinfo.h" line="332"/>
      <constructor name="new" c:identifier="g_app_launch_context_new">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1566">Creates a new application launch context. This is not normally used,
instead you instantiate a subclass of this, such as
[`GdkAppLaunchContext`](https://docs.gtk.org/gdk4/class.AppLaunchContext.html).</doc>
        <source-position filename="gio/gappinfo.h" line="337"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1573">a launch context.</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </return-value>
      </constructor>
      <virtual-method name="get_display" invoker="get_display">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1785">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the `DISPLAY` environment variable.</doc>
        <source-position filename="gio/gappinfo.h" line="313"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1795">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1787">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1788">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1789">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_startup_notify_id"
                      invoker="get_startup_notify_id">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1815">Initiates startup notification for the application and returns the
`XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
if supported.

The returned token may be referred to equivalently as an ‘activation token’
(using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).

Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
and startup notification IDs are defined in the
[freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).

Support for the XDG Activation Protocol was added in GLib 2.76.
Since GLib 2.82 @info and @files can be `NULL`. If that’s not supported by the backend,
the returned token will be `NULL`.</doc>
        <source-position filename="gio/gappinfo.h" line="316"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1837">a startup notification ID for the application, or `NULL` if
  not supported.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1817">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1818">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1819">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_failed" invoker="launch_failed">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1859">Called when an application has failed to launch, so that it can cancel
the application startup notification started in
[method@Gio.AppLaunchContext.get_startup_notify_id].</doc>
        <source-position filename="gio/gappinfo.h" line="319"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1861">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1862">the startup notification id that was returned by
  [method@Gio.AppLaunchContext.get_startup_notify_id].</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_started">
        <source-position filename="gio/gappinfo.h" line="324"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launched">
        <source-position filename="gio/gappinfo.h" line="321"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_display"
              c:identifier="g_app_launch_context_get_display">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1785">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the `DISPLAY` environment variable.</doc>
        <source-position filename="gio/gappinfo.h" line="350"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1795">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1787">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1788">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1789">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_environment"
              c:identifier="g_app_launch_context_get_environment"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1760">Gets the complete environment variable list to be passed to
the child process when @context is used to launch an application.
This is a `NULL`-terminated array of strings, where each string has
the form `KEY=VALUE`.</doc>
        <source-position filename="gio/gappinfo.h" line="347"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1769">
  the child’s environment</doc>
          <array c:type="char**">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1762">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_startup_notify_id"
              c:identifier="g_app_launch_context_get_startup_notify_id">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1815">Initiates startup notification for the application and returns the
`XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
if supported.

The returned token may be referred to equivalently as an ‘activation token’
(using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).

Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
and startup notification IDs are defined in the
[freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).

Support for the XDG Activation Protocol was added in GLib 2.76.
Since GLib 2.82 @info and @files can be `NULL`. If that’s not supported by the backend,
the returned token will be `NULL`.</doc>
        <source-position filename="gio/gappinfo.h" line="354"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gappinfo.c"
               line="1837">a startup notification ID for the application, or `NULL` if
  not supported.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1817">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1818">the app info</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1819">a list of [iface@Gio.File] objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="launch_failed"
              c:identifier="g_app_launch_context_launch_failed">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1859">Called when an application has failed to launch, so that it can cancel
the application startup notification started in
[method@Gio.AppLaunchContext.get_startup_notify_id].</doc>
        <source-position filename="gio/gappinfo.h" line="358"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1861">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1862">the startup notification id that was returned by
  [method@Gio.AppLaunchContext.get_startup_notify_id].</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="setenv"
              c:identifier="g_app_launch_context_setenv"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1709">Arranges for @variable to be set to @value in the child’s environment when
@context is used to launch an application.</doc>
        <source-position filename="gio/gappinfo.h" line="340"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1711">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1712">the environment variable to set</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1713">the value for to set the variable to.</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsetenv"
              c:identifier="g_app_launch_context_unsetenv"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1736">Arranges for @variable to be unset in the child’s environment when @context
is used to launch an application.</doc>
        <source-position filename="gio/gappinfo.h" line="344"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1738">the launch context</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </instance-parameter>
          <parameter name="variable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1739">the environment variable to remove</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AppLaunchContextPrivate"
              c:type="GAppLaunchContextPrivate*"/>
      </field>
      <glib:signal name="launch-failed" when="last" version="2.36">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1598">The [signal@Gio.AppLaunchContext::launch-failed] signal is emitted when a
[iface@Gio.AppInfo] launch fails. The startup notification id is provided,
so that the launcher can cancel the startup notification.

Because a launch operation may involve spawning multiple instances of the
target application, you should expect this signal to be emitted multiple
times, one for each spawned instance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1601">the startup notification id for the failed launch</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="launch-started" when="last" version="2.72">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1620">The [signal@Gio.AppLaunchContext::launch-started] signal is emitted when a
[iface@Gio.AppInfo] is about to be launched. If non-null the
@platform_data is an GVariant dictionary mapping strings to variants
(ie `a{sv}`), which contains additional, platform-specific data about this
launch. On UNIX, at least the `startup-notification-id` keys will be
present.

The value of the `startup-notification-id` key (type `s`) is a startup
notification ID corresponding to the format from the [startup-notification
specification](https://specifications.freedesktop.org/startup-notification-spec/startup-notification-0.1.txt).
It allows tracking the progress of the launchee through startup.

It is guaranteed that this signal is followed by either a
[signal@Gio.AppLaunchContext::launched] or
[signal@Gio.AppLaunchContext::launch-failed] signal.

Because a launch operation may involve spawning multiple instances of the
target application, you should expect this signal to be emitted multiple
times, one for each spawned instance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1623">the [iface@Gio.AppInfo] that is about to be launched</doc>
            <type name="AppInfo"/>
          </parameter>
          <parameter name="platform_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1624">additional platform-specific data for this launch</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="launched" when="last" version="2.36">
        <doc xml:space="preserve"
             filename="gio/gappinfo.c"
             line="1660">The [signal@Gio.AppLaunchContext::launched] signal is emitted when a
[iface@Gio.AppInfo] is successfully launched.

Because a launch operation may involve spawning multiple instances of the
target application, you should expect this signal to be emitted multiple
times, one time for each spawned instance.

The @platform_data is an GVariant dictionary mapping
strings to variants (ie `a{sv}`), which contains additional,
platform-specific data about this launch. On UNIX, at least the
`pid` and `startup-notification-id` keys will be present.

Since 2.72 the `pid` may be 0 if the process id wasn’t known (for
example if the process was launched via D-Bus). The `pid` may not be
set at all in subsequent releases.

On Windows, `pid` is guaranteed to be valid only for the duration of the
[signal@Gio.AppLaunchContext::launched] signal emission; after the signal
is emitted, GLib will call [func@GLib.spawn_close_pid]. If you need to
keep the [alias@GLib.Pid] after the signal has been emitted, then you can
duplicate `pid` using `DuplicateHandle()`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1663">the [iface@Gio.AppInfo] that was just launched</doc>
            <type name="AppInfo"/>
          </parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1664">additional platform-specific data for this launch</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AppLaunchContextClass"
            c:type="GAppLaunchContextClass"
            glib:is-gtype-struct-for="AppLaunchContext">
      <source-position filename="gio/gappinfo.h" line="332"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_display">
        <callback name="get_display">
          <source-position filename="gio/gappinfo.h" line="313"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1795">a display string for the display.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1787">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1788">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1789">a list of [iface@Gio.File] objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_startup_notify_id">
        <callback name="get_startup_notify_id">
          <source-position filename="gio/gappinfo.h" line="316"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gappinfo.c"
                 line="1837">a startup notification ID for the application, or `NULL` if
  not supported.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1817">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1818">the app info</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1819">a list of [iface@Gio.File] objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_failed">
        <callback name="launch_failed">
          <source-position filename="gio/gappinfo.h" line="319"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1861">the launch context</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="startup_notify_id" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gappinfo.c"
                   line="1862">the startup notification id that was returned by
  [method@Gio.AppLaunchContext.get_startup_notify_id].</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launched">
        <callback name="launched">
          <source-position filename="gio/gappinfo.h" line="321"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_started">
        <callback name="launch_started">
          <source-position filename="gio/gappinfo.h" line="324"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <source-position filename="gio/gappinfo.h" line="329"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <source-position filename="gio/gappinfo.h" line="330"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <source-position filename="gio/gappinfo.h" line="331"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="AppLaunchContextPrivate"
            c:type="GAppLaunchContextPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gio/gappinfo.h" line="47"/>
    </record>
    <class name="Application"
           c:symbol-prefix="application"
           c:type="GApplication"
           version="2.28"
           parent="GObject.Object"
           glib:type-name="GApplication"
           glib:get-type="g_application_get_type"
           glib:type-struct="ApplicationClass">
      <doc xml:space="preserve"
           filename="gio/gapplication.c"
           line="48">`GApplication` is the core class for application support.

A `GApplication` is the foundation of an application. It wraps some
low-level platform-specific services and is intended to act as the
foundation for higher-level application classes such as
`GtkApplication` or `MxApplication`. In general, you should not use
this class outside of a higher level framework.

`GApplication` provides convenient life-cycle management by maintaining
a "use count" for the primary application instance. The use count can
be changed using [method@Gio.Application.hold] and
[method@Gio.Application.release]. If it drops to zero, the application
exits. Higher-level classes such as `GtkApplication` employ the use count
to ensure that the application stays alive as long as it has any opened
windows.

Another feature that `GApplication` (optionally) provides is process
uniqueness. Applications can make use of this functionality by
providing a unique application ID. If given, only one application
with this ID can be running at a time per session. The session
concept is platform-dependent, but corresponds roughly to a graphical
desktop login. When your application is launched again, its
arguments are passed through platform communication to the already
running program. The already running instance of the program is
called the "primary instance"; for non-unique applications this is
always the current instance. On Linux, the D-Bus session bus
is used for communication.

The use of `GApplication` differs from some other commonly-used
uniqueness libraries (such as libunique) in important ways. The
application is not expected to manually register itself and check
if it is the primary instance. Instead, the main() function of a
`GApplication` should do very little more than instantiating the
application instance, possibly connecting signal handlers, then
calling [method@Gio.Application.run]. All checks for uniqueness are done
internally. If the application is the primary instance then the
startup signal is emitted and the mainloop runs. If the application
is not the primary instance then a signal is sent to the primary
instance and [method@Gio.Application.run] promptly returns. See the code
examples below.

If used, the expected form of an application identifier is the
same as that of a
[D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
`org._7_zip.Archiver`.
For details on valid application identifiers, see [func@Gio.Application.id_is_valid].

On Linux, the application identifier is claimed as a well-known bus name
on the user's session bus. This means that the uniqueness of your
application is scoped to the current session. It also means that your
application may provide additional services (through registration of other
object paths) at that bus name. The registration of these object paths
should be done with the shared GDBus session bus. Note that due to the
internal architecture of GDBus, method calls can be dispatched at any time
(even if a main loop is not running). For this reason, you must ensure that
any object paths that you wish to register are registered before #GApplication
attempts to acquire the bus name of your application (which happens in
[method@Gio.Application.register]). Unfortunately, this means that you cannot
use [property@Gio.Application:is-remote] to decide if you want to register
object paths.

`GApplication` also implements the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
interfaces and lets you easily export actions by adding them with
[method@Gio.ActionMap.add_action]. When invoking an action by calling
[method@Gio.ActionGroup.activate_action] on the application, it is always
invoked in the primary instance. The actions are also exported on
the session bus, and GIO provides the [class@Gio.DBusActionGroup] wrapper to
conveniently access them remotely. GIO provides a [class@Gio.DBusMenuModel] wrapper
for remote access to exported [class@Gio.MenuModel]s.

Note: Due to the fact that actions are exported on the session bus,
using `maybe` parameters is not supported, since D-Bus does not support
`maybe` types.

There is a number of different entry points into a `GApplication`:

- via 'Activate' (i.e. just starting the application)

- via 'Open' (i.e. opening some files)

- by handling a command-line

- via activating an action

The [signal@Gio.Application::startup] signal lets you handle the application
initialization for all of these in a single place.

Regardless of which of these entry points is used to start the
application, `GApplication` passes some ‘platform data’ from the
launching instance to the primary instance, in the form of a
[struct@GLib.Variant] dictionary mapping strings to variants. To use platform
data, override the [vfunc@Gio.Application.before_emit] or
[vfunc@Gio.Application.after_emit] virtual functions
in your `GApplication` subclass. When dealing with
[class@Gio.ApplicationCommandLine] objects, the platform data is
directly available via [method@Gio.ApplicationCommandLine.get_cwd],
[method@Gio.ApplicationCommandLine.get_environ] and
[method@Gio.ApplicationCommandLine.get_platform_data].

As the name indicates, the platform data may vary depending on the
operating system, but it always includes the current directory (key
`cwd`), and optionally the environment (ie the set of environment
variables and their values) of the calling process (key `environ`).
The environment is only added to the platform data if the
`G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
can add their own platform data by overriding the
[vfunc@Gio.Application.add_platform_data] virtual function. For instance,
`GtkApplication` adds startup notification data in this way.

To parse commandline arguments you may handle the
[signal@Gio.Application::command-line] signal or override the
[vfunc@Gio.Application.local_command_line] virtual function, to parse them in
either the primary instance or the local instance, respectively.

For an example of opening files with a `GApplication`, see
[gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).

For an example of using actions with `GApplication`, see
[gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).

For an example of using extra D-Bus hooks with `GApplication`, see
[gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).</doc>
      <source-position filename="gio/gapplication.h" line="124"/>
      <implements name="ActionGroup"/>
      <implements name="ActionMap"/>
      <constructor name="new" c:identifier="g_application_new">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1869">Creates a new #GApplication instance.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().

If no application ID is given then some features of #GApplication
(most notably application uniqueness) will be disabled.</doc>
        <source-position filename="gio/gapplication.h" line="133"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1882">a new #GApplication instance</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
        <parameters>
          <parameter name="application_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1871">the application id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1872">the application flags</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_default"
                c:identifier="g_application_get_default"
                version="2.32">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2898">Returns the default #GApplication instance for this process.

Normally there is only one #GApplication per process and it becomes
the default when it is created.  You can exercise more control over
this by using g_application_set_default().

If there is no default application then %NULL is returned.</doc>
        <source-position filename="gio/gapplication.h" line="232"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2909">the default application for this process, or %NULL</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
      </function>
      <function name="id_is_valid" c:identifier="g_application_id_is_valid">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1809">Checks if @application_id is a valid application identifier.

A valid ID is required for calls to g_application_new() and
g_application_set_application_id().

Application identifiers follow the same format as
[D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
For convenience, the restrictions on application identifiers are
reproduced here:

- Application identifiers are composed of 1 or more elements separated by a
  period (`.`) character. All elements must contain at least one character.

- Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
  with `-` discouraged in new application identifiers. Each element must not
  begin with a digit.

- Application identifiers must contain at least one `.` (period) character
  (and thus at least two elements).

- Application identifiers must not begin with a `.` (period) character.

- Application identifiers must not exceed 255 characters.

Note that the hyphen (`-`) character is allowed in application identifiers,
but is problematic or not allowed in various specifications and APIs that
refer to D-Bus, such as
[Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
the
[`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
and the convention that an application's "main" interface and object path
resemble its application identifier and bus name. To avoid situations that
require special-case handling, it is recommended that new application
identifiers consistently replace hyphens with underscores.

Like D-Bus interface names, application identifiers should start with the
reversed DNS domain name of the author of the interface (in lower-case), and
it is conventional for the rest of the application identifier to consist of
words run together, with initial capital letters.

As with D-Bus interface names, if the author's DNS domain name contains
hyphen/minus characters they should be replaced by underscores, and if it
contains leading digits they should be escaped by prepending an underscore.
For example, if the owner of 7-zip.org used an application identifier for an
archiving application, it might be named `org._7_zip.Archiver`.</doc>
        <source-position filename="gio/gapplication.h" line="130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1859">%TRUE if @application_id is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="application_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1811">a potential application identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2430">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <source-position filename="gio/gapplication.h" line="63"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2432">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_platform_data">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="198">invoked (locally) to add 'platform data' to be sent to
    the primary instance when activating, opening or invoking actions</doc>
        <source-position filename="gio/gapplication.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="GLib.VariantBuilder" c:type="GVariantBuilder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="after_emit">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="195">invoked on the primary instance after 'activate', 'open',
    'command-line' or any action invocation, gets the 'platform data' from
    the calling instance</doc>
        <source-position filename="gio/gapplication.h" line="103"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="before_emit">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="192">invoked on the primary instance before 'activate', 'open',
    'command-line' or any action invocation, gets the 'platform data' from
    the calling instance</doc>
        <source-position filename="gio/gapplication.h" line="100"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="command_line">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="185">invoked on the primary instance when a command-line is
  not handled locally</doc>
        <source-position filename="gio/gapplication.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="command_line" transfer-ownership="none">
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dbus_register" throws="1">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="207">invoked locally during registration, if the application is
    using its D-Bus backend. You can use this to export extra objects on the
    bus, that need to exist before the application tries to own the bus name.
    The function is passed the #GDBusConnection to to session bus, and the
    object path that #GApplication will use to export its D-Bus API.
    If this function returns %TRUE, registration will proceed; otherwise
    registration will abort. Since: 2.34</doc>
        <source-position filename="gio/gapplication.h" line="111"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dbus_unregister">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="214">invoked locally during unregistration, if the application
    is using its D-Bus backend. Use this to undo anything done by
    the @dbus_register vfunc. Since: 2.34</doc>
        <source-position filename="gio/gapplication.h" line="115"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_local_options">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="217">invoked locally after the parsing of the commandline
 options has occurred. Since: 2.40</doc>
        <source-position filename="gio/gapplication.h" line="118"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <type name="GLib.VariantDict" c:type="GVariantDict*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_command_line">
        <doc xml:space="preserve"
             filename="gio/gapplication.h"
             line="75">This virtual function is always invoked in the local instance. It
gets passed a pointer to a %NULL-terminated copy of @argv and is
expected to remove arguments that it handled (shifting up remaining
arguments).

The last argument to local_command_line() is a pointer to the @status
variable which can used to set the exit status that is returned from
g_application_run().

See g_application_run() for more details on #GApplication startup.</doc>
        <source-position filename="gio/gapplication.h" line="94"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.h"
               line="92">%TRUE if the commandline has been completely handled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.h"
                 line="77">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="arguments"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gapplication.h"
                 line="78">array of command line arguments</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="exit_status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gapplication.h"
                 line="79">exit status to fill after processing the command line.</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="name_lost">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="219">invoked when another instance is taking over the name. Since: 2.60</doc>
        <source-position filename="gio/gapplication.h" line="120"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open" invoker="open" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2457">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <source-position filename="gio/gapplication.h" line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2459">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2460">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**">
              <type name="File" c:type="GFile*"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2461">the length of the @files array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2462">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="quit_mainloop">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="200">Used to be invoked on the primary instance when the use
    count of the application drops to zero (and after any inactivity
    timeout, if requested). Not used anymore since 2.32</doc>
        <source-position filename="gio/gapplication.h" line="107"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="run_mainloop">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="203">Used to be invoked on the primary instance from
    g_application_run() if the use-count is non-zero. Since 2.32,
    GApplication is iterating the main context directly and is not
    using @run_mainloop anymore</doc>
        <source-position filename="gio/gapplication.h" line="108"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="shutdown">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="181">invoked only on the registered primary instance immediately
     after the main loop terminates</doc>
        <source-position filename="gio/gapplication.h" line="109"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="startup">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="180">invoked on the primary instance immediately after registration</doc>
        <source-position filename="gio/gapplication.h" line="61"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate"
              c:identifier="g_application_activate"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2430">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <source-position filename="gio/gapplication.h" line="215"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2432">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_main_option"
              c:identifier="g_application_add_main_option"
              version="2.42">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="768">Add an option to be handled by @application.

Calling this function is the equivalent of calling
g_application_add_main_option_entries() with a single #GOptionEntry
that has its arg_data member set to %NULL.

The parsed arguments will be packed into a #GVariantDict which
is passed to #GApplication::handle-local-options. If
%G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
be sent to the primary instance. See
g_application_add_main_option_entries() for more details.

See #GOptionEntry for more documentation of the arguments.</doc>
        <source-position filename="gio/gapplication.h" line="180"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="770">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="long_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="771">the long name of an option used to specify it in a commandline</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="short_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="772">the short name of an option</doc>
            <type name="gchar" c:type="char"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="773">flags from #GOptionFlags</doc>
            <type name="GLib.OptionFlags" c:type="GOptionFlags"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="774">the type of the option, as a #GOptionArg</doc>
            <type name="GLib.OptionArg" c:type="GOptionArg"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="775">the description for the option in `--help` output</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="arg_description"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="776">the placeholder to use for the extra argument
   parsed by the option in `--help` output</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_main_option_entries"
              c:identifier="g_application_add_main_option_entries"
              version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="672">Adds main option entries to be handled by @application.

This function is comparable to g_option_context_add_main_entries().

After the commandline arguments are parsed, the
#GApplication::handle-local-options signal will be emitted.  At this
point, the application can inspect the values pointed to by @arg_data
in the given #GOptionEntrys.

Unlike #GOptionContext, #GApplication supports giving a %NULL
@arg_data for a non-callback #GOptionEntry.  This results in the
argument in question being packed into a #GVariantDict which is also
passed to #GApplication::handle-local-options, where it can be
inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
set, then the resulting dictionary is sent to the primary instance,
where g_application_command_line_get_options_dict() will return it.
As it has been passed outside the process at this point, the types of all
values in the options dict must be checked before being used.
This "packing" is done according to the type of the argument --
booleans for normal flags, strings for strings, bytestrings for
filenames, etc.  The packing only occurs if the flag is given (ie: we
do not pack a "false" #GVariant in the case that a flag is missing).

In general, it is recommended that all commandline arguments are
parsed locally.  The options dictionary should then be used to
transmit the result of the parsing to the primary instance, where
g_variant_dict_lookup() can be used.  For local options, it is
possible to either use @arg_data in the usual way, or to consult (and
potentially remove) the option from the options dictionary.

This function is new in GLib 2.40.  Before then, the only real choice
was to send all of the commandline arguments (options and all) to the
primary instance for handling.  #GApplication ignored them completely
on the local side.  Calling this function "opts in" to the new
behaviour, and in particular, means that unrecognized options will be
treated as errors.  Unrecognized options have never been ignored when
%G_APPLICATION_HANDLES_COMMAND_LINE is unset.

If #GApplication::handle-local-options needs to see the list of
filenames, then the use of %G_OPTION_REMAINING is recommended.  If
@arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
the options dictionary.  If you do use %G_OPTION_REMAINING then you
need to handle these arguments for yourself because once they are
consumed, they will no longer be visible to the default handling
(which treats them as filenames to be opened).

It is important to use the proper GVariant format when retrieving
the options with g_variant_dict_lookup():
- for %G_OPTION_ARG_NONE, use `b`
- for %G_OPTION_ARG_STRING, use `&amp;s`
- for %G_OPTION_ARG_INT, use `i`
- for %G_OPTION_ARG_INT64, use `x`
- for %G_OPTION_ARG_DOUBLE, use `d`
- for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
- for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
- for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`</doc>
        <source-position filename="gio/gapplication.h" line="176"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="674">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="675">the
  main options for the application</doc>
            <array c:type="const GOptionEntry*">
              <type name="GLib.OptionEntry"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_option_group"
              c:identifier="g_application_add_option_group"
              version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="826">Adds a #GOptionGroup to the commandline handling of @application.

This function is comparable to g_option_context_add_group().

Unlike g_application_add_main_option_entries(), this function does
not deal with %NULL @arg_data and never transmits options to the
primary instance.

The reason for that is because, by the time the options arrive at the
primary instance, it is typically too late to do anything with them.
Taking the GTK option group as an example: GTK will already have been
initialised by the time the #GApplication::command-line handler runs.
In the case that this is not the first-running instance of the
application, the existing instance may already have been running for
a very long time.

This means that the options from #GOptionGroup are only really usable
in the case that the instance of the application being run is the
first instance.  Passing options like `--display=` or `--gdk-debug=`
on future runs will have no effect on the existing primary instance.

Calling this function will cause the options in the supplied option
group to be parsed, but it does not cause you to be "opted in" to the
new functionality whereby unrecognized options are rejected even if
%G_APPLICATION_HANDLES_COMMAND_LINE was given.</doc>
        <source-position filename="gio/gapplication.h" line="188"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="828">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="829">a #GOptionGroup</doc>
            <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_busy_property"
              c:identifier="g_application_bind_busy_property"
              version="2.44">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3191">Marks @application as busy (see g_application_mark_busy()) while
@property on @object is %TRUE.

The binding holds a reference to @application while it is active, but
not to @object. Instead, the binding is destroyed when @object is
finalized.</doc>
        <source-position filename="gio/gapplication.h" line="252"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3193">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3194">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3195">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_application_id"
              c:identifier="g_application_get_application_id"
              glib:get-property="application-id"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1897">Gets the unique identifier for @application.</doc>
        <source-position filename="gio/gapplication.h" line="137"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1903">the identifier for @application, owned by @application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1899">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_connection"
              c:identifier="g_application_get_dbus_connection"
              version="2.34">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2220">Gets the #GDBusConnection being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the #GDBusConnection being used for uniqueness and
communication with the desktop environment and other instances of the
application.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <source-position filename="gio/gapplication.h" line="149"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2238">a #GDBusConnection, or %NULL</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2222">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_object_path"
              c:identifier="g_application_get_dbus_object_path"
              version="2.34">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2251">Gets the D-Bus object path being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the D-Bus object path that #GApplication is using.  If the
application is the primary instance then there is an object published
at this path.  If the application is not the primary instance then
the result of this function is undefined.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <source-position filename="gio/gapplication.h" line="151"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2270">the object path, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2253">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="g_application_get_flags"
              glib:get-property="flags"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1992">Gets the flags for @application.

See #GApplicationFlags.</doc>
        <source-position filename="gio/gapplication.h" line="160"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2000">the flags for @application</doc>
          <type name="ApplicationFlags" c:type="GApplicationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1994">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inactivity_timeout"
              c:identifier="g_application_get_inactivity_timeout"
              glib:get-property="inactivity-timeout"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2120">Gets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.</doc>
        <source-position filename="gio/gapplication.h" line="154"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2129">the timeout, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2122">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_busy"
              c:identifier="g_application_get_is_busy"
              glib:get-property="is-busy"
              version="2.44">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3032">Gets the application's current busy state, as set through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <source-position filename="gio/gapplication.h" line="241"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="3039">%TRUE if @application is currently marked as busy</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3034">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_registered"
              c:identifier="g_application_get_is_registered"
              glib:get-property="is-registered"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2171">Checks if @application is registered.

An application is registered if g_application_register() has been
successfully called.</doc>
        <source-position filename="gio/gapplication.h" line="200"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2180">%TRUE if @application is registered</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2173">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_remote"
              c:identifier="g_application_get_is_remote"
              glib:get-property="is-remote"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2192">Checks if @application is remote.

If @application is remote then it means that another instance of
application already exists (the 'primary' instance).  Calls to
perform actions on @application will result in the actions being
performed by the primary instance.

The value of this property cannot be accessed before
g_application_register() has been called.  See
g_application_get_is_registered().</doc>
        <source-position filename="gio/gapplication.h" line="202"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2207">%TRUE if @application is remote</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2194">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resource_base_path"
              c:identifier="g_application_get_resource_base_path"
              glib:get-property="resource-base-path"
              version="2.42">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2042">Gets the resource base path of @application.

See g_application_set_resource_base_path() for more information.</doc>
        <source-position filename="gio/gapplication.h" line="166"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2050">the base resource path, if one is set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2044">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version"
              c:identifier="g_application_get_version"
              glib:get-property="version"
              version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1948">Gets the version of @application.</doc>
        <source-position filename="gio/gapplication.h" line="143"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1954">the version of @application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1950">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hold" c:identifier="g_application_hold">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2368">Increases the use count of @application.

Use this function to indicate that the application has a reason to
continue to run.  For example, g_application_hold() is called by GTK
when a toplevel window is on the screen.

To cancel the hold, call g_application_release().</doc>
        <source-position filename="gio/gapplication.h" line="210"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2370">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mark_busy"
              c:identifier="g_application_mark_busy"
              version="2.38">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2966">Increases the busy count of @application.

Use this function to indicate that the application is busy, for instance
while a long running operation is pending.

The busy state will be exposed to other processes, so a session shell will
use that information to indicate the state to the user (e.g. with a
spinner).

To cancel the busy indication, use g_application_unmark_busy().

The application must be registered before calling this function.</doc>
        <source-position filename="gio/gapplication.h" line="237"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2968">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="g_application_open" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2457">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <source-position filename="gio/gapplication.h" line="218"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2459">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2460">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**">
              <type name="File" c:type="GFile*"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2461">the length of the @files array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2462">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="quit" c:identifier="g_application_quit" version="2.32">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2938">Immediately quits the application.

Upon return to the mainloop, g_application_run() will return,
calling only the 'shutdown' function before doing so.

The hold count is ignored.
Take care if your code has called g_application_hold() on the application and
is therefore still expecting it to exist.
(Note that you may have called g_application_hold() indirectly, for example
through gtk_application_add_window().)

The result of calling g_application_run() again after it returns is
unspecified.</doc>
        <source-position filename="gio/gapplication.h" line="229"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2940">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="g_application_register"
              version="2.28"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2285">Attempts registration of the application.

This is the point at which the application discovers if it is the
primary instance or merely acting as a remote for an already-existing
primary instance.  This is implemented by attempting to acquire the
application identifier as a unique bus name on the session bus using
GDBus.

If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
given, then this process will always become the primary instance.

Due to the internal architecture of GDBus, method calls can be
dispatched at any time (even if a main loop is not running).  For
this reason, you must ensure that any object paths that you wish to
register are registered before calling this function.

If the application has already been registered then %TRUE is
returned with no work performed.

The #GApplication::startup signal is emitted if registration succeeds
and @application is the primary instance (including the non-unique
case).

In the event of an error (such as @cancellable being cancelled, or a
failure to connect to the session bus), %FALSE is returned and @error
is set appropriately.

Note: the return value of this function is not an indicator that this
instance is or is not the primary instance of the application.  See
g_application_get_is_remote() for that.</doc>
        <source-position filename="gio/gapplication.h" line="205"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2322">%TRUE if registration succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2287">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2288">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="g_application_release">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2405">Decrease the use count of @application.

When the use count reaches zero, the application will stop running.

Never call this function except to cancel the effect of a previous
call to g_application_hold().</doc>
        <source-position filename="gio/gapplication.h" line="212"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2407">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="g_application_run" version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2503">Runs the application.

This function is intended to be run from main() and its return value
is intended to be returned by main(). Although you are expected to pass
the @argc, @argv parameters from main() to this function, it is possible
to pass %NULL if @argv is not available or commandline handling is not
required.  Note that on Windows, @argc and @argv are ignored, and
g_win32_get_command_line() is called internally (for proper support
of Unicode commandline arguments).

#GApplication will attempt to parse the commandline arguments.  You
can add commandline flags to the list of recognised options by way of
g_application_add_main_option_entries().  After this, the
#GApplication::handle-local-options signal is emitted, from which the
application can inspect the values of its #GOptionEntrys.

#GApplication::handle-local-options is a good place to handle options
such as `--version`, where an immediate reply from the local process is
desired (instead of communicating with an already-running instance).
A #GApplication::handle-local-options handler can stop further processing
by returning a non-negative value, which then becomes the exit status of
the process.

What happens next depends on the flags: if
%G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
commandline arguments are sent to the primary instance, where a
#GApplication::command-line signal is emitted.  Otherwise, the
remaining commandline arguments are assumed to be a list of files.
If there are no files listed, the application is activated via the
#GApplication::activate signal.  If there are one or more files, and
%G_APPLICATION_HANDLES_OPEN was specified then the files are opened
via the #GApplication::open signal.

If you are interested in doing more complicated local handling of the
commandline then you should implement your own #GApplication subclass
and override local_command_line(). In this case, you most likely want
to return %TRUE from your local_command_line() implementation to
suppress the default handling. See
[gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
for an example.

If, after the above is done, the use count of the application is zero
then the exit status is returned immediately.  If the use count is
non-zero then the default main context is iterated until the use count
falls to zero, at which point 0 is returned.

If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
run for as much as 10 seconds with a use count of zero while waiting
for the message that caused the activation to arrive.  After that,
if the use count falls to zero the application will exit immediately,
except in the case that g_application_set_inactivity_timeout() is in
use.

This function sets the prgname (g_set_prgname()), if not already set,
to the basename of argv[0].

Much like g_main_loop_run(), this function will acquire the main context
for the duration that the application is running.

Since 2.40, applications that are not explicitly flagged as services
or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
%G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
default handler for local_command_line) if "--gapplication-service"
was given in the command line.  If this flag is present then normal
commandline processing is interrupted and the
%G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
solution whereby running an application directly from the commandline
will invoke it in the normal way (which can be useful for debugging)
while still allowing applications to be D-Bus activated in service
mode.  The D-Bus service file should invoke the executable with
"--gapplication-service" as the sole commandline argument.  This
approach is suitable for use by most graphical applications but
should not be used from applications like editors that need precise
control over when processes invoked via the commandline will exit and
what their exit status will be.</doc>
        <source-position filename="gio/gapplication.h" line="224"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="2586">the exit status</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2505">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2506">the argc from main() (or 0 if @argv is %NULL)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2507">
    the argv from main(), or %NULL</doc>
            <array length="0" zero-terminated="0" c:type="char**">
              <type name="filename"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="send_notification"
              c:identifier="g_application_send_notification"
              version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3053">Sends a notification on behalf of @application to the desktop shell.
There is no guarantee that the notification is displayed immediately,
or even at all.

Notifications may persist after the application exits. It will be
D-Bus-activated when the notification or one of its actions is
activated.

Modifying @notification after this call has no effect. However, the
object can be reused for a later call to this function.

@id may be any string that uniquely identifies the event for the
application. It does not need to be in any special format. For
example, "new-message" might be appropriate for a notification about
new messages.

If a previous notification was sent with the same @id, it will be
replaced with @notification and shown again as if it was a new
notification. This works even for notifications sent from a previous
execution of the application, as long as @id is the same string.

@id may be `NULL`, but it is impossible to replace or withdraw
notifications without an id.

If @notification is no longer relevant, it can be withdrawn with
[method@Gio.Application.withdraw_notification].

It is an error to call this function if @application has no
application ID.</doc>
        <source-position filename="gio/gapplication.h" line="244"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3055">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3056">id of the notification, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="notification" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3057">the #GNotification to send</doc>
            <type name="Notification" c:type="GNotification*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_action_group"
              c:identifier="g_application_set_action_group"
              glib:set-property="action-group"
              version="2.28"
              deprecated="1"
              deprecated-version="2.32">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1299">This used to be how actions were associated with a #GApplication.
Now there is #GActionMap for that.</doc>
        <doc-deprecated xml:space="preserve">Use the #GActionMap interface instead.  Never ever
mix use of this API with use of #GActionMap on the same @application
or things will go very badly wrong.  This function is known to
introduce buggy behaviour (ie: signals not emitted on changes to the
action group), so you should really use #GActionMap instead.</doc-deprecated>
        <source-position filename="gio/gapplication.h" line="172"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1301">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="action_group"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1302">a #GActionGroup, or %NULL</doc>
            <type name="ActionGroup" c:type="GActionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_application_id"
              c:identifier="g_application_set_application_id"
              glib:set-property="application-id"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1915">Sets the unique identifier for @application.

The application id can only be modified if @application has not yet
been registered.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().</doc>
        <source-position filename="gio/gapplication.h" line="139"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1917">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="application_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1918">the identifier for @application</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default"
              c:identifier="g_application_set_default"
              version="2.32">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2919">Sets or unsets the default application for the process, as returned
by g_application_get_default().

This function does not take its own reference on @application.  If
@application is destroyed then the default application will revert
back to %NULL.</doc>
        <source-position filename="gio/gapplication.h" line="234"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2921">the application to set as default, or %NULL</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="g_application_set_flags"
              glib:set-property="flags"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2012">Sets the flags for @application.

The flags can only be modified if @application has not yet been
registered.

See #GApplicationFlags.</doc>
        <source-position filename="gio/gapplication.h" line="162"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2014">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2015">the flags for @application</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_inactivity_timeout"
              c:identifier="g_application_set_inactivity_timeout"
              glib:set-property="inactivity-timeout"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2141">Sets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.

This call has no side effects of its own.  The value set here is only
used for next time g_application_release() drops the use count to
zero.  Any timeouts currently in progress are not impacted.</doc>
        <source-position filename="gio/gapplication.h" line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2143">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="inactivity_timeout" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2144">the timeout, in milliseconds</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_description"
              c:identifier="g_application_set_option_context_description"
              version="2.56">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="916">Adds a description to the @application option context.

See g_option_context_set_description() for more information.</doc>
        <source-position filename="gio/gapplication.h" line="197"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="918">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="description"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="919">a string to be shown in `--help` output
 after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_parameter_string"
              c:identifier="g_application_set_option_context_parameter_string"
              version="2.56">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="869">Sets the parameter string to be used by the commandline handling of @application.

This function registers the argument to be passed to g_option_context_new()
when the internal #GOptionContext of @application is created.

See g_option_context_new() for more information about @parameter_string.</doc>
        <source-position filename="gio/gapplication.h" line="191"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="871">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="parameter_string"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="872">a string which is displayed
  in the first line of `--help` output, after the usage summary `programname [OPTION...]`.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option_context_summary"
              c:identifier="g_application_set_option_context_summary"
              version="2.56">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="894">Adds a summary to the @application option context.

See g_option_context_set_summary() for more information.</doc>
        <source-position filename="gio/gapplication.h" line="194"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="896">the #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="summary"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="897">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resource_base_path"
              c:identifier="g_application_set_resource_base_path"
              glib:set-property="resource-base-path"
              version="2.42">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="2062">Sets (or unsets) the base resource path of @application.

The path is used to automatically load various [application
resources][gresource] such as menu layouts and action descriptions.
The various types of resources will be found at fixed names relative
to the given base path.

By default, the resource base path is determined from the application
ID by prefixing '/' and replacing each '.' with '/'.  This is done at
the time that the #GApplication object is constructed.  Changes to
the application ID after that point will not have an impact on the
resource base path.

As an example, if the application has an ID of "org.example.app" then
the default resource base path will be "/org/example/app".  If this
is a #GtkApplication (and you have not manually changed the path)
then Gtk will then search for the menus of the application at
"/org/example/app/gtk/menus.ui".

See #GResource for more information about adding resources to your
application.

You can disable automatic resource loading functionality by setting
the path to %NULL.

Changing the resource base path once the application is running is
not recommended.  The point at which the resource path is consulted
for forming paths for various purposes is unspecified.  When writing
a sub-class of #GApplication you should either set the
#GApplication:resource-base-path property at construction time, or call
this function during the instance initialization. Alternatively, you
can call this function in the #GApplicationClass.startup virtual function,
before chaining up to the parent implementation.</doc>
        <source-position filename="gio/gapplication.h" line="168"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2064">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="resource_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="2065">the resource path to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_version"
              c:identifier="g_application_set_version"
              glib:set-property="version"
              version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1966">Sets the version number of @application. This will be used to implement
a `--version` command line argument

The application version can only be modified if @application has not yet
been registered.</doc>
        <source-position filename="gio/gapplication.h" line="145"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1968">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1969">the version of @application</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unbind_busy_property"
              c:identifier="g_application_unbind_busy_property"
              version="2.44">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3246">Destroys a binding between @property and the busy state of
@application that was previously created with
g_application_bind_busy_property().</doc>
        <source-position filename="gio/gapplication.h" line="257"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3248">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3249">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3250">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmark_busy"
              c:identifier="g_application_unmark_busy"
              version="2.38">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3003">Decreases the busy count of @application.

When the busy count reaches zero, the new state will be propagated
to other processes.

This function must only be called to cancel the effect of a previous
call to g_application_mark_busy().</doc>
        <source-position filename="gio/gapplication.h" line="239"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3005">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="withdraw_notification"
              c:identifier="g_application_withdraw_notification"
              version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="3118">Withdraws a notification that was sent with
g_application_send_notification().

This call does nothing if a notification with @id doesn't exist or
the notification was never sent.

This function works even for notifications sent in previous
executions of this application, as long @id is the same as it was for
the sent notification.

Note that notifications are dismissed when the user clicks on one
of the buttons in a notification or triggers its default action, so
there is no need to explicitly withdraw the notification in that case.</doc>
        <source-position filename="gio/gapplication.h" line="248"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3120">a #GApplication</doc>
            <type name="Application" c:type="GApplication*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="3121">id of a previously sent notification</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="action-group"
                version="2.28"
                deprecated="1"
                deprecated-version="2.32"
                readable="0"
                writable="1"
                transfer-ownership="none"
                setter="set_action_group">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1611">The group of actions that the application exports.</doc>
        <doc-deprecated xml:space="preserve">Use the [iface@Gio.ActionMap] interface instead.
  Never ever mix use of this API with use of `GActionMap` on the
  same @application or things will go very badly wrong.</doc-deprecated>
        <type name="ActionGroup"/>
      </property>
      <property name="application-id"
                version="2.28"
                writable="1"
                construct="1"
                transfer-ownership="none"
                setter="set_application_id"
                getter="get_application_id"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1530">The unique identifier for the application.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags"
                version="2.28"
                writable="1"
                transfer-ownership="none"
                setter="set_flags"
                getter="get_flags"
                default-value="G_APPLICATION_FLAGS_NONE">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1554">Flags specifying the behaviour of the application.</doc>
        <type name="ApplicationFlags"/>
      </property>
      <property name="inactivity-timeout"
                version="2.28"
                writable="1"
                transfer-ownership="none"
                setter="set_inactivity_timeout"
                getter="get_inactivity_timeout"
                default-value="0">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1599">Time (in milliseconds) to stay alive after becoming idle.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="is-busy"
                version="2.44"
                transfer-ownership="none"
                getter="get_is_busy"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1626">Whether the application is currently marked as busy through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-registered"
                version="2.28"
                transfer-ownership="none"
                getter="get_is_registered"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1577">Whether [method@Gio.Application.register] has been called.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-remote"
                version="2.28"
                transfer-ownership="none"
                getter="get_is_remote"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1588">Whether this application instance is remote.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="resource-base-path"
                version="2.28"
                writable="1"
                transfer-ownership="none"
                setter="set_resource_base_path"
                getter="get_resource_base_path"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1566">The base resource path for the application.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="version"
                version="2.80"
                writable="1"
                transfer-ownership="none"
                setter="set_version"
                getter="get_version"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1542">The human-readable version number of the application.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ApplicationPrivate" c:type="GApplicationPrivate*"/>
      </field>
      <glib:signal name="activate" when="last">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1662">The ::activate signal is emitted on the primary instance when an
activation occurs. See g_application_activate().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="command-line" when="last">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1695">The ::command-line signal is emitted on the primary instance when
a commandline is not handled locally. See g_application_run() and
the #GApplicationCommandLine documentation for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1705">An integer that is set as the exit status for the calling
  process. See g_application_command_line_set_exit_status().</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="command_line" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1698">a #GApplicationCommandLine representing the
    passed commandline</doc>
            <type name="ApplicationCommandLine"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="handle-local-options" when="last" version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1718">The ::handle-local-options signal is emitted on the local instance
after the parsing of the commandline options has occurred.

You can add options to be recognised during commandline option
parsing using g_application_add_main_option_entries() and
g_application_add_option_group().

Signal handlers can inspect @options (along with values pointed to
from the @arg_data of an installed #GOptionEntrys) in order to
decide to perform certain actions, including direct local handling
(which may be useful for options like --version).

In the event that the application is marked
%G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
send the @options dictionary to the primary instance where it can be
read with g_application_command_line_get_options_dict().  The signal
handler can modify the dictionary before returning, and the
modified dictionary will be sent.

In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
"normal processing" will treat the remaining uncollected command
line arguments as filenames or URIs.  If there are no arguments,
the application is activated by g_application_activate().  One or
more arguments results in a call to g_application_open().

If you want to handle the local commandline arguments for yourself
by converting them to calls to g_application_open() or
g_action_group_activate_action() then you must be sure to register
the application first.  You should probably not call
g_application_activate() for yourself, however: just return -1 and
allow the default handler to do it for you.  This will ensure that
the `--gapplication-service` switch works properly (i.e. no activation
in that case).

Note that this signal is emitted from the default implementation of
local_command_line().  If you override that function and don't
chain up then this signal will never be emitted.

You can override local_command_line() if you need more powerful
capabilities than what is provided here, but this should not
normally be required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1765">an exit code. If you have handled your options and want
to exit the process, return a non-negative option, 0 for success,
and a positive value for failure. To continue, return -1 to let
the default option processing continue.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1721">the options dictionary</doc>
            <type name="GLib.VariantDict"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="name-lost" when="last" version="2.60">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1782">The ::name-lost signal is emitted only on the registered primary instance
when a new instance has taken over. This can only happen if the application
is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.

The default handler for this signal calls g_application_quit().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplication.c"
               line="1792">%TRUE if the signal has been handled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </glib:signal>
      <glib:signal name="open" when="last">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1675">The ::open signal is emitted on the primary instance when there are
files to open. See g_application_open() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1678">an array of #GFiles</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="File"/>
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1679">the length of @files</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.c"
                 line="1680">a hint provided by the calling instance</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="shutdown" when="last">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1650">The ::shutdown signal is emitted only on the registered primary instance
immediately after the main loop terminates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="startup" when="first">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="1638">The ::startup signal is emitted on the primary instance immediately
after registration. See g_application_register().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ApplicationClass"
            c:type="GApplicationClass"
            glib:is-gtype-struct-for="Application"
            version="2.28">
      <doc xml:space="preserve"
           filename="gio/gapplication.c"
           line="178">Virtual function table for #GApplication.</doc>
      <source-position filename="gio/gapplication.h" line="124"/>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="startup">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="180">invoked on the primary instance immediately after registration</doc>
        <callback name="startup">
          <source-position filename="gio/gapplication.h" line="61"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="183">invoked on the primary instance when an activation occurs</doc>
        <callback name="activate">
          <source-position filename="gio/gapplication.h" line="63"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.c"
                   line="2432">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="184">invoked on the primary instance when there are files to open</doc>
        <callback name="open">
          <source-position filename="gio/gapplication.h" line="65"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.c"
                   line="2459">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.c"
                   line="2460">an array of #GFiles to open</doc>
              <array length="2" zero-terminated="0" c:type="GFile**">
                <type name="File" c:type="GFile*"/>
              </array>
            </parameter>
            <parameter name="n_files" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.c"
                   line="2461">the length of the @files array</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="hint" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.c"
                   line="2462">a hint (or ""), but never %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="command_line">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="185">invoked on the primary instance when a command-line is
  not handled locally</doc>
        <callback name="command_line">
          <source-position filename="gio/gapplication.h" line="70"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="command_line" transfer-ownership="none">
              <type name="ApplicationCommandLine"
                    c:type="GApplicationCommandLine*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_command_line">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="187">invoked (locally). The virtual function has the chance
    to inspect (and possibly replace) command line arguments. See
    g_application_run() for more information. Also see the
    #GApplication::handle-local-options signal, which is a simpler
    alternative to handling some commandline options locally</doc>
        <callback name="local_command_line">
          <source-position filename="gio/gapplication.h" line="94"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplication.h"
                 line="92">%TRUE if the commandline has been completely handled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplication.h"
                   line="77">a #GApplication</doc>
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="arguments"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="gio/gapplication.h"
                   line="78">array of command line arguments</doc>
              <array c:type="gchar***">
                <type name="utf8" c:type="gchar**"/>
              </array>
            </parameter>
            <parameter name="exit_status"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="gio/gapplication.h"
                   line="79">exit status to fill after processing the command line.</doc>
              <type name="gint" c:type="int*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="before_emit">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="192">invoked on the primary instance before 'activate', 'open',
    'command-line' or any action invocation, gets the 'platform data' from
    the calling instance</doc>
        <callback name="before_emit">
          <source-position filename="gio/gapplication.h" line="100"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="after_emit">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="195">invoked on the primary instance after 'activate', 'open',
    'command-line' or any action invocation, gets the 'platform data' from
    the calling instance</doc>
        <callback name="after_emit">
          <source-position filename="gio/gapplication.h" line="103"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_platform_data">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="198">invoked (locally) to add 'platform data' to be sent to
    the primary instance when activating, opening or invoking actions</doc>
        <callback name="add_platform_data">
          <source-position filename="gio/gapplication.h" line="105"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="GLib.VariantBuilder" c:type="GVariantBuilder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit_mainloop">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="200">Used to be invoked on the primary instance when the use
    count of the application drops to zero (and after any inactivity
    timeout, if requested). Not used anymore since 2.32</doc>
        <callback name="quit_mainloop">
          <source-position filename="gio/gapplication.h" line="107"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="run_mainloop">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="203">Used to be invoked on the primary instance from
    g_application_run() if the use-count is non-zero. Since 2.32,
    GApplication is iterating the main context directly and is not
    using @run_mainloop anymore</doc>
        <callback name="run_mainloop">
          <source-position filename="gio/gapplication.h" line="108"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="shutdown">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="181">invoked only on the registered primary instance immediately
     after the main loop terminates</doc>
        <callback name="shutdown">
          <source-position filename="gio/gapplication.h" line="109"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dbus_register">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="207">invoked locally during registration, if the application is
    using its D-Bus backend. You can use this to export extra objects on the
    bus, that need to exist before the application tries to own the bus name.
    The function is passed the #GDBusConnection to to session bus, and the
    object path that #GApplication will use to export its D-Bus API.
    If this function returns %TRUE, registration will proceed; otherwise
    registration will abort. Since: 2.34</doc>
        <callback name="dbus_register" throws="1">
          <source-position filename="gio/gapplication.h" line="111"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dbus_unregister">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="214">invoked locally during unregistration, if the application
    is using its D-Bus backend. Use this to undo anything done by
    the @dbus_register vfunc. Since: 2.34</doc>
        <callback name="dbus_unregister">
          <source-position filename="gio/gapplication.h" line="115"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_local_options">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="217">invoked locally after the parsing of the commandline
 options has occurred. Since: 2.40</doc>
        <callback name="handle_local_options">
          <source-position filename="gio/gapplication.h" line="118"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="options" transfer-ownership="none">
              <type name="GLib.VariantDict" c:type="GVariantDict*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="name_lost">
        <doc xml:space="preserve"
             filename="gio/gapplication.c"
             line="219">invoked when another instance is taking over the name. Since: 2.60</doc>
        <callback name="name_lost">
          <source-position filename="gio/gapplication.h" line="120"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="7">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="ApplicationCommandLine"
           c:symbol-prefix="application_command_line"
           c:type="GApplicationCommandLine"
           parent="GObject.Object"
           glib:type-name="GApplicationCommandLine"
           glib:get-type="g_application_command_line_get_type"
           glib:type-struct="ApplicationCommandLineClass">
      <doc xml:space="preserve"
           filename="gio/gapplicationcommandline.c"
           line="42">`GApplicationCommandLine` represents a command-line invocation of
an application.

It is created by [class@Gio.Application] and emitted
in the [signal@Gio.Application::command-line] signal and virtual function.

The class contains the list of arguments that the program was invoked
with. It is also possible to query if the commandline invocation was
local (ie: the current process is running in direct response to the
invocation) or remote (ie: some other process forwarded the
commandline to this process).

The `GApplicationCommandLine` object can provide the @argc and @argv
parameters for use with the [struct@GLib.OptionContext] command-line parsing API,
with the [method@Gio.ApplicationCommandLine.get_arguments] function. See
[gapplication-example-cmdline3.c][gapplication-example-cmdline3]
for an example.

The exit status of the originally-invoked process may be set and
messages can be printed to stdout or stderr of that process.

For remote invocation, the originally-invoked process exits when
[method@Gio.ApplicationCommandLine.done] method is called. This method is
also automatically called when the object is disposed.

The main use for `GApplicationCommandLine` (and the
[signal@Gio.Application::command-line] signal) is 'Emacs server' like use cases:
You can set the `EDITOR` environment variable to have e.g. git use
your favourite editor to edit commit messages, and if you already
have an instance of the editor running, the editing will happen
in the running instance, instead of opening a new one. An important
aspect of this use case is that the process that gets started by git
does not return until the editing is done.

Normally, the commandline is completely handled in the
[signal@Gio.Application::command-line] handler. The launching instance exits
once the signal handler in the primary instance has returned, and
the return value of the signal handler becomes the exit status
of the launching instance.

```c
static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  gchar **argv;
  gint argc;
  gint i;

  argv = g_application_command_line_get_arguments (cmdline, &amp;argc);

  g_application_command_line_print (cmdline,
                                    "This text is written back\n"
                                    "to stdout of the caller\n");

  for (i = 0; i &lt; argc; i++)
    g_print ("argument %d: %s\n", i, argv[i]);

  g_strfreev (argv);

  return 0;
}
```

The complete example can be found here:
[gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)

In more complicated cases, the handling of the commandline can be
split between the launcher and the primary instance.

```c
static gboolean
 test_local_cmdline (GApplication   *application,
                     gchar        ***arguments,
                     gint           *exit_status)
{
  gint i, j;
  gchar **argv;

  argv = *arguments;

  if (argv[0] == NULL)
    {
      *exit_status = 0;
      return FALSE;
    }

  i = 1;
  while (argv[i])
    {
      if (g_str_has_prefix (argv[i], "--local-"))
        {
          g_print ("handling argument %s locally\n", argv[i]);
          g_free (argv[i]);
          for (j = i; argv[j]; j++)
            argv[j] = argv[j + 1];
        }
      else
        {
          g_print ("not handling argument %s locally\n", argv[i]);
          i++;
        }
    }

  *exit_status = 0;

  return FALSE;
}

static void
test_application_class_init (TestApplicationClass *class)
{
  G_APPLICATION_CLASS (class)-&gt;local_command_line = test_local_cmdline;

  ...
}
```

In this example of split commandline handling, options that start
with `--local-` are handled locally, all other options are passed
to the [signal@Gio.Application::command-line] handler which runs in the primary
instance.

The complete example can be found here:
[gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)

If handling the commandline requires a lot of work, it may be better to defer it.

```c
static gboolean
my_cmdline_handler (gpointer data)
{
  GApplicationCommandLine *cmdline = data;

  // do the heavy lifting in an idle

  g_application_command_line_set_exit_status (cmdline, 0);
  g_object_unref (cmdline); // this releases the application

  return G_SOURCE_REMOVE;
}

static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  // keep the application running until we are done with this commandline
  g_application_hold (application);

  g_object_set_data_full (G_OBJECT (cmdline),
                          "application", application,
                          (GDestroyNotify)g_application_release);

  g_object_ref (cmdline);
  g_idle_add (my_cmdline_handler, cmdline);

  return 0;
}
```

In this example the commandline is not completely handled before
the [signal@Gio.Application::command-line] handler returns. Instead, we keep
a reference to the `GApplicationCommandLine` object and handle it
later (in this example, in an idle). Note that it is necessary to
hold the application until you are done with the commandline.

The complete example can be found here:
[gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)</doc>
      <source-position filename="gio/gapplicationcommandline.h" line="73"/>
      <virtual-method name="done" invoker="done" version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="941">Signals that command line processing is completed.

For remote invocation, it causes the invoking process to terminate.

For local invocation, it does nothing.

This method should be called in the [signal@Gio.Application::command-line]
handler, after the exit status is set and all messages are printed.

After this call, g_application_command_line_set_exit_status() has no effect.
Subsequent calls to this method are no-ops.

This method is automatically called when the #GApplicationCommandLine
object is disposed — so you can omit the call in non-garbage collected
languages.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="943">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_stdin" invoker="get_stdin" version="2.34">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="565">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a D-Bus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="69"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="580">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="567">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="print_literal"
                      invoker="print_literal"
                      version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="698">Prints a message using the stdout print handler in the invoking process.

Unlike g_application_command_line_print(), @message is not a `printf()`-style
format string. Use this function if @message contains text you don't have
control over, that could include `printf()` escape sequences.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="700">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="701">the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="printerr_literal"
                      invoker="printerr_literal"
                      version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="722">Prints a message using the stderr print handler in the invoking process.

Unlike g_application_command_line_printerr(), @message is not
a `printf()`-style format string. Use this function if @message contains text
you don't have control over, that could include `printf()` escape sequences.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="724">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="725">the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_file_for_arg"
              c:identifier="g_application_command_line_create_file_for_arg"
              version="2.36">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="910">Creates a #GFile corresponding to a filename that was given as part
of the invocation of @cmdline.

This differs from g_file_new_for_commandline_arg() in that it
resolves relative pathnames using the current working directory of
the invoking process rather than the local process.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="127"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="922">a new #GFile</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="912">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="arg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="913">an argument from @cmdline</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="done"
              c:identifier="g_application_command_line_done"
              version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="941">Signals that command line processing is completed.

For remote invocation, it causes the invoking process to terminate.

For local invocation, it does nothing.

This method should be called in the [signal@Gio.Application::command-line]
handler, after the exit status is set and all messages are printed.

After this call, g_application_command_line_set_exit_status() has no effect.
Subsequent calls to this method are no-ops.

This method is automatically called when the #GApplicationCommandLine
object is disposed — so you can omit the call in non-garbage collected
languages.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="131"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="943">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_arguments"
              c:identifier="g_application_command_line_get_arguments"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="494">Gets the list of arguments that was passed on the command line.

The strings in the array may contain non-UTF-8 data on UNIX (such as
filenames or arguments given in the system locale) but are always in
UTF-8 on Windows.

If you wish to use the return value with #GOptionContext, you must
use g_option_context_parse_strv().

The return value is %NULL-terminated and should be freed using
g_strfreev().</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="79"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="511">
     the string array containing the arguments (the argv)</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="496">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="argc"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="497">the length of the arguments array, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cwd"
              c:identifier="g_application_command_line_get_cwd"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="590">Gets the working directory of the command line invocation.
The string may contain non-utf8 data.

It is possible that the remote application did not send a working
directory, so this may be %NULL.

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="96"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="603">the current directory, or %NULL</doc>
          <type name="filename" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="592">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_environ"
              c:identifier="g_application_command_line_get_environ"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="613">Gets the contents of the 'environ' variable of the command line
invocation, as would be returned by g_get_environ(), ie as a
%NULL-terminated list of strings in the form 'NAME=VALUE'.
The strings may contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.

See g_application_command_line_getenv() if you are only interested
in the value of a single environment variable.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="633">
    the environment strings, or %NULL if they were not sent</doc>
          <array c:type="const gchar* const*">
            <type name="filename"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="615">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_exit_status"
              c:identifier="g_application_command_line_get_exit_status"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="860">Gets the exit status of @cmdline.  See
g_application_command_line_set_exit_status() for more information.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="867">the exit status</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="862">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_remote"
              c:identifier="g_application_command_line_get_is_remote"
              glib:get-property="is-remote"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="682">Determines if @cmdline represents a remote invocation.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="688">%TRUE if the invocation was remote</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="684">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_options_dict"
              c:identifier="g_application_command_line_get_options_dict"
              version="2.40">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="533">Gets the options that were passed to g_application_command_line().

If you did not override local_command_line() then these are the same
options that were parsed according to the #GOptionEntrys added to the
application with g_application_add_main_option_entries() and possibly
modified from your GApplication::handle-local-options handler.

If no options were sent then an empty dictionary is returned so that
you don't need to check for %NULL.

The data has been passed via an untrusted external process, so the types of
all values must be checked before being used.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="83"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="550">a #GVariantDict with the options</doc>
          <type name="GLib.VariantDict" c:type="GVariantDict*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="535">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_platform_data"
              c:identifier="g_application_command_line_get_platform_data"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="879">Gets the platform data associated with the invocation of @cmdline.

This is a #GVariant dictionary containing information about the
context in which the invocation occurred.  It typically contains
information like the current working directory and the startup
notification ID.

It comes from an untrusted external process and hence the types of all
values must be validated before being used.

For local invocation, it will be %NULL.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="124"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="895">the platform data, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="881">#GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stdin"
              c:identifier="g_application_command_line_get_stdin"
              version="2.34">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="565">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a D-Bus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="86"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="580">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="567">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="getenv"
              c:identifier="g_application_command_line_getenv"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="644">Gets the value of a particular environment variable of the command
line invocation, as would be returned by g_getenv().  The strings may
contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="92"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gapplicationcommandline.c"
               line="661">the value of the variable, or %NULL if unset or unsent</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="646">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="647">the environment variable to get</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print"
              c:identifier="g_application_command_line_print"
              version="2.28"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="746">Formats a message and prints it using the stdout print handler in the
invoking process.

If @cmdline is a local invocation then this is exactly equivalent to
g_print().  If @cmdline is remote then this is equivalent to calling
g_print() in the invoking process.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="109"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="748">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="749">a printf-style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="750">arguments, as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="print_literal"
              c:identifier="g_application_command_line_print_literal"
              version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="698">Prints a message using the stdout print handler in the invoking process.

Unlike g_application_command_line_print(), @message is not a `printf()`-style
format string. Use this function if @message contains text you don't have
control over, that could include `printf()` escape sequences.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="102"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="700">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="701">the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="printerr"
              c:identifier="g_application_command_line_printerr"
              version="2.28"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="781">Formats a message and prints it using the stderr print handler in the
invoking process.

If @cmdline is a local invocation then this is exactly equivalent to
g_printerr().  If @cmdline is remote then this is equivalent to
calling g_printerr() in the invoking process.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="113"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="783">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="784">a printf-style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="785">arguments, as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="printerr_literal"
              c:identifier="g_application_command_line_printerr_literal"
              version="2.80">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="722">Prints a message using the stderr print handler in the invoking process.

Unlike g_application_command_line_printerr(), @message is not
a `printf()`-style format string. Use this function if @message contains text
you don't have control over, that could include `printf()` escape sequences.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="724">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="725">the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_exit_status"
              c:identifier="g_application_command_line_set_exit_status"
              version="2.28">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="816">Sets the exit status that will be used when the invoking process
exits.

The return value of the #GApplication::command-line signal is
passed to this function when the handler returns.  This is the usual
way of setting the exit status.

In the event that you want the remote invocation to continue running
and want to decide on the exit status in the future, you can use this
call.  For the case of a remote invocation, the remote process will
typically exit when the last reference is dropped on @cmdline.  The
exit status of the remote process will be equal to the last value
that was set with this function.

In the case that the commandline invocation is local, the situation
is slightly more complicated.  If the commandline invocation results
in the mainloop running (ie: because the use-count of the application
increased to a non-zero value) then the application is considered to
have been 'successful' in a certain sense, and the exit status is
always zero.  If the application use count is zero, though, the exit
status of the local #GApplicationCommandLine is used.

This method is a no-op if g_application_command_line_done() has
been called.</doc>
        <source-position filename="gio/gapplicationcommandline.h" line="120"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="818">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine"
                  c:type="GApplicationCommandLine*"/>
          </instance-parameter>
          <parameter name="exit_status" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="819">the exit status</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="arguments"
                version="2.28"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="441">The commandline that caused this [signal@Gio.Application::command-line]
signal emission.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="is-remote"
                version="2.28"
                transfer-ownership="none"
                getter="get_is_remote"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="480">Whether this is a remote commandline.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="options"
                version="2.28"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="455">The options sent along with the commandline.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="platform-data"
                version="2.28"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gio/gapplicationcommandline.c"
             line="467">Platform-specific data for the commandline.</doc>
        <type name="GLib.Variant"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ApplicationCommandLinePrivate"
              c:type="GApplicationCommandLinePrivate*"/>
      </field>
    </class>
    <record name="ApplicationCommandLineClass"
            c:type="GApplicationCommandLineClass"
            glib:is-gtype-struct-for="ApplicationCommandLine"
            version="2.28">
      <doc xml:space="preserve"
           filename="gio/gapplicationcommandline.c"
           line="215">The #GApplicationCommandLineClass-struct
contains private data only.</doc>
      <source-position filename="gio/gapplicationcommandline.h" line="73"/>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="print_literal">
        <callback name="print_literal">
          <source-position filename="gio/gapplicationcommandline.h" line="65"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="700">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine"
                    c:type="GApplicationCommandLine*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="701">the message</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="printerr_literal">
        <callback name="printerr_literal">
          <source-position filename="gio/gapplicationcommandline.h" line="67"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="724">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine"
                    c:type="GApplicationCommandLine*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="725">the message</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_stdin">
        <callback name="get_stdin">
          <source-position filename="gio/gapplicationcommandline.h" line="69"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="gio/gapplicationcommandline.c"
                 line="580">a #GInputStream for stdin</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="567">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine"
                    c:type="GApplicationCommandLine*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="done">
        <callback name="done">
          <source-position filename="gio/gapplicationcommandline.h" line="70"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gapplicationcommandline.c"
                   line="943">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine"
                    c:type="GApplicationCommandLine*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="10">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ApplicationCommandLinePrivate"
            c:type="GApplicationCommandLinePrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gio/gapplicationcommandline.h" line="49"/>
    </record>
    <bitfield name="ApplicationFlags"
              version="2.28"
              glib:type-name="GApplicationFlags"
              glib:get-type="g_application_flags_get_type"
              c:type="GApplicationFlags">
      <doc xml:space="preserve"
           filename="gio/gioenums.h"
           line="1497">Flags used to define the behaviour of a #GApplication.</doc>
      <member name="flags_none"
              value="0"
              c:identifier="G_APPLICATION_FLAGS_NONE"
              glib:nick="flags-none"
              glib:name="G_APPLICATION_FLAGS_NONE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1499">Default. Deprecated in 2.74, use
  %G_APPLICATION_DEFAULT_FLAGS instead</doc>
      </member>
      <member name="default_flags"
              value="0"
              c:identifier="G_APPLICATION_DEFAULT_FLAGS"
              glib:nick="default-flags"
              glib:name="G_APPLICATION_DEFAULT_FLAGS">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1501">Default flags. Since: 2.74</doc>
      </member>
      <member name="is_service"
              value="1"
              c:identifier="G_APPLICATION_IS_SERVICE"
              glib:nick="is-service"
              glib:name="G_APPLICATION_IS_SERVICE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1502">Run as a service. In this mode, registration
     fails if the service is already running, and the application
     will initially wait up to 10 seconds for an initial activation
     message to arrive.</doc>
      </member>
      <member name="is_launcher"
              value="2"
              c:identifier="G_APPLICATION_IS_LAUNCHER"
              glib:nick="is-launcher"
              glib:name="G_APPLICATION_IS_LAUNCHER">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1506">Don't try to become the primary instance.</doc>
      </member>
      <member name="handles_open"
              value="4"
              c:identifier="G_APPLICATION_HANDLES_OPEN"
              glib:nick="handles-open"
              glib:name="G_APPLICATION_HANDLES_OPEN">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1507">This application handles opening files (in
    the primary instance). Note that this flag only affects the default
    implementation of local_command_line(), and has no effect if
    %G_APPLICATION_HANDLES_COMMAND_LINE is given.
    See g_application_run() for details.</doc>
      </member>
      <member name="handles_command_line"
              value="8"
              c:identifier="G_APPLICATION_HANDLES_COMMAND_LINE"
              glib:nick="handles-command-line"
              glib:name="G_APPLICATION_HANDLES_COMMAND_LINE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1512">This application handles command line
    arguments (in the primary instance). Note that this flag only affect
    the default implementation of local_command_line().
    See g_application_run() for details.</doc>
      </member>
      <member name="send_environment"
              value="16"
              c:identifier="G_APPLICATION_SEND_ENVIRONMENT"
              glib:nick="send-environment"
              glib:name="G_APPLICATION_SEND_ENVIRONMENT">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1516">Send the environment of the
    launching process to the primary instance. Set this flag if your
    application is expected to behave differently depending on certain
    environment variables. For instance, an editor might be expected
    to use the `GIT_COMMITTER_NAME` environment variable
    when editing a git commit message. The environment is available
    to the #GApplication::command-line signal handler, via
    g_application_command_line_getenv().</doc>
      </member>
      <member name="non_unique"
              value="32"
              c:identifier="G_APPLICATION_NON_UNIQUE"
              glib:nick="non-unique"
              glib:name="G_APPLICATION_NON_UNIQUE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1524">Make no attempts to do any of the typical
    single-instance application negotiation, even if the application
    ID is given.  The application neither attempts to become the
    owner of the application ID nor does it check if an existing
    owner already exists.  Everything occurs in the local process.
    Since: 2.30.</doc>
      </member>
      <member name="can_override_app_id"
              value="64"
              c:identifier="G_APPLICATION_CAN_OVERRIDE_APP_ID"
              glib:nick="can-override-app-id"
              glib:name="G_APPLICATION_CAN_OVERRIDE_APP_ID">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1530">Allow users to override the
    application ID from the command line with `--gapplication-app-id`.
    Since: 2.48</doc>
      </member>
      <member name="allow_replacement"
              value="128"
              c:identifier="G_APPLICATION_ALLOW_REPLACEMENT"
              glib:nick="allow-replacement"
              glib:name="G_APPLICATION_ALLOW_REPLACEMENT">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1533">Allow another instance to take over
    the bus name. Since: 2.60</doc>
      </member>
      <member name="replace"
              value="256"
              c:identifier="G_APPLICATION_REPLACE"
              glib:nick="replace"
              glib:name="G_APPLICATION_REPLACE">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="1535">Take over from another instance. This flag is
    usually set by passing `--gapplication-replace` on the commandline.
    Since: 2.60</doc>
      </member>
    </bitfield>
    <record name="ApplicationPrivate"
            c:type="GApplicationPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gio/gapplication.h" line="43"/>
    </record>
    <bitfield name="AskPasswordFlags"
              glib:type-name="GAskPasswordFlags"
              glib:get-type="g_ask_password_flags_get_type"
              c:type="GAskPasswordFlags">
      <doc xml:space="preserve"
           filename="gio/gioenums.h"
           line="595">#GAskPasswordFlags are used to request specific information from the
user, or to notify the user of their choices in an authentication
situation.</doc>
      <member name="need_password"
              value="1"
              c:identifier="G_ASK_PASSWORD_NEED_PASSWORD"
              glib:nick="need-password"
              glib:name="G_ASK_PASSWORD_NEED_PASSWORD">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="597">operation requires a password.</doc>
      </member>
      <member name="need_username"
              value="2"
              c:identifier="G_ASK_PASSWORD_NEED_USERNAME"
              glib:nick="need-username"
              glib:name="G_ASK_PASSWORD_NEED_USERNAME">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="598">operation requires a username.</doc>
      </member>
      <member name="need_domain"
              value="4"
              c:identifier="G_ASK_PASSWORD_NEED_DOMAIN"
              glib:nick="need-domain"
              glib:name="G_ASK_PASSWORD_NEED_DOMAIN">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="599">operation requires a domain.</doc>
      </member>
      <member name="saving_supported"
              value="8"
              c:identifier="G_ASK_PASSWORD_SAVING_SUPPORTED"
              glib:nick="saving-supported"
              glib:name="G_ASK_PASSWORD_SAVING_SUPPORTED">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="600">operation supports saving settings.</doc>
      </member>
      <member name="anonymous_supported"
              value="16"
              c:identifier="G_ASK_PASSWORD_ANONYMOUS_SUPPORTED"
              glib:nick="anonymous-supported"
              glib:name="G_ASK_PASSWORD_ANONYMOUS_SUPPORTED">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="601">operation supports anonymous users.</doc>
      </member>
      <member name="tcrypt"
              value="32"
              c:identifier="G_ASK_PASSWORD_TCRYPT"
              glib:nick="tcrypt"
              glib:name="G_ASK_PASSWORD_TCRYPT">
        <doc xml:space="preserve"
             filename="gio/gioenums.h"
             line="602">operation takes TCRYPT parameters (Since: 2.58)</doc>
      </member>
    </bitfield>
    <interface name="AsyncInitable"
               c:symbol-prefix="async_initable"
               c:type="GAsyncInitable"
               version="2.22"
               glib:type-name="GAsyncInitable"
               glib:get-type="g_async_initable_get_type"
               glib:type-struct="AsyncInitableIface">
      <doc xml:space="preserve"
           filename="gio/gasyncinitable.c"
           line="31">`GAsyncInitable` is an interface for asynchronously initializable objects.

This is the asynchronous version of [iface@Gio.Initable]; it behaves the same
in all ways except that initialization is asynchronous. For more details
see the descriptions on `GInitable`.

A class may implement both the `GInitable` and `GAsyncInitable` interfaces.

Users of objects implementing this are not intended to use the interface
method directly; instead it will be used automatically in various ways.
For C applications you generally just call [func@Gio.AsyncInitable.new_async]
directly, or indirectly via a foo_thing_new_async() wrapper. This will call
[method@Gio.AsyncInitable.init_async] under the covers, calling back with `NULL`
and a set `GError` on failure.

A typical implementation might look something like this:

```c
enum {
   NOT_INITIALIZED,
   INITIALIZING,
   INITIALIZED
};

static void
_foo_ready_cb (Foo *self)
{
  GList *l;

  self-&gt;priv-&gt;state = INITIALIZED;

  for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
    {
      GTask *task = l-&gt;data;

      if (self-&gt;priv-&gt;success)
        g_task_return_boolean (task, TRUE);
      else
        g_task_return_new_error (task, ...);
      g_object_unref (task);
    }

  g_list_free (self-&gt;priv-&gt;init_results);
  self-&gt;priv-&gt;init_results = NULL;
}

static void
foo_init_async (GAsyncInitable       *initable,
                int                   io_priority,
                GCancellable         *cancellable,
                GAsyncReadyCallback   callback,
                gpointer              user_data)
{
  Foo *self = FOO (initable);
  GTask *task;

  task = g_task_new (initable, cancellable, callback, user_data);
  g_task_set_name (task, G_STRFUNC);

  switch (self-&gt;priv-&gt;state)
    {
      case NOT_INITIALIZED:
        _foo_get_ready (self);
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        self-&gt;priv-&gt;state = INITIALIZING;
        break;
      case INITIALIZING:
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        break;
      case INITIALIZED:
        if (!self-&gt;priv-&gt;success)
          g_task_return_new_error (task, ...);
        else
          g_task_return_boolean (task, TRUE);
        g_object_unref (task);
        break;
    }
}

static gboolean
foo_init_finish (GAsyncInitable       *initable,
                 GAsyncResult         *result,
                 GError              **error)
{
  g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);

  return g_task_propagate_boolean (G_TASK (result), error);
}

static void
foo_async_initable_iface_init (gpointer g_iface,
                               gpointer data)
{
  GAsyncInitableIface *iface = g_iface;

  iface-&gt;init_async = foo_init_async;
  iface-&gt;init_finish = foo_init_finish;
}
```</doc>
      <source-position filename="gio/gasyncinitable.h" line="68"/>
      <function name="new_async"
                c:identifier="g_async_initable_new_async"
                version="2.22"
                introspectable="0">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="313">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_new() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <source-position filename="gio/gasyncinitable.h" line="86"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="315">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="316">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="317">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="318">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="320">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="first_property_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="321">the name of the first property, or %NULL if no
    properties</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="323">the value of the first property, followed by other property
   value pairs, and ended by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="new_valist_async"
                c:identifier="g_async_initable_new_valist_async"
                version="2.22"
                introspectable="0">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="399">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_new_valist() but also initializes the object
asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <source-position filename="gio/gasyncinitable.h" line="108"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="401">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="402">the name of the first property, followed by
the value, and other property value pairs, and ended by %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="404">The var args list generated from @first_property_name.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="405">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="406">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="407">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="409">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="newv_async"
                c:identifier="g_async_initable_newv_async"
                version="2.22"
                deprecated="1"
                deprecated-version="2.54">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="354">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_newv() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_async_initable_init_async() instead. See #GParameter for more information.</doc-deprecated>
        <source-position filename="gio/gasyncinitable.h" line="97"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="356">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="357">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="358">the parameters to use to construct the object</doc>
            <type name="GObject.Parameter" c:type="GParameter*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="359">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="360">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="361">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="363">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="init_async"
                      invoker="init_async"
                      version="2.22"
                      glib:finish-func="init_finish">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="160">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <source-position filename="gio/gasyncinitable.h" line="60"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="162">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="163">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="164">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="165">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="166">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="init_finish"
                      invoker="init_finish"
                      version="2.22"
                      throws="1">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="223">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <source-position filename="gio/gasyncinitable.h" line="65"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gasyncinitable.c"
               line="233">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="225">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="226">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="init_async"
              c:identifier="g_async_initable_init_async"
              version="2.22"
              glib:finish-func="init_finish">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="160">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <source-position filename="gio/gasyncinitable.h" line="75"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="162">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="163">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="164">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="165">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="166">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_finish"
              c:identifier="g_async_initable_init_finish"
              version="2.22"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="223">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <source-position filename="gio/gasyncinitable.h" line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/gasyncinitable.c"
               line="233">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="225">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="226">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_finish"
              c:identifier="g_async_initable_new_finish"
              version="2.22"
              throws="1">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.c"
             line="444">Finishes the async construction for the various g_async_initable_new
calls, returning the created object or %NULL on error.</doc>
        <source-position filename="gio/gasyncinitable.h" line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gio/gasyncinitable.c"
               line="453">a newly created #GObject,
     or %NULL on error. Free with g_object_unref().</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="446">the #GAsyncInitable from the callback</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="447">the #GAsyncResult from the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="AsyncInitableIface"
            c:type="GAsyncInitableIface"
            glib:is-gtype-struct-for="AsyncInitable"
            version="2.22">
      <doc xml:space="preserve"
           filename="gio/gasyncinitable.h"
           line="43">Provides an interface for asynchronous initializing object such that
initialization may fail.</doc>
      <source-position filename="gio/gasyncinitable.h" line="68"/>
      <field name="g_iface">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.h"
             line="45">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="init_async">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.h"
             line="46">Starts initialization of the object.</doc>
        <callback name="init_async">
          <source-position filename="gio/gasyncinitable.h" line="60"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="162">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="163">the [I/O priority](iface.AsyncResult.html#io-priority) of the operation</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="164">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="165">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="166">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_finish">
        <doc xml:space="preserve"
             filename="gio/gasyncinitable.h"
             line="47">Finishes initialization of the object.</doc>
        <callback name="init_finish" throws="1">
          <source-position filename="gio/gasyncinitable.h" line="65"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncinitable.c"
                 line="233">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="225">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gio/gasyncinitable.c"
                   line="226">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="AsyncReadyCallback" c:type="GAsyncReadyCallback">
      <doc xml:space="preserve"
           filename="gio/giotypes.h"
           line="171">Type definition for a function that will be called back when an asynchronous
operation within GIO has been completed. #GAsyncReadyCallback
callbacks from #GTask are guaranteed to be invoked in a later
iteration of the
[thread-default main context][g-main-context-push-thread-default]
where the #GTask was created. All other users of
#GAsyncReadyCallback must likewise call it asynchronously in a
later iteration of the main context.

The asynchronous operation is guaranteed to have held a reference to
@source_object from the time when the `*_async()` function was called, until
after this callback returns.</doc>
      <source-position filename="gio/giotypes.h" line="190"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gio/giotypes.h"
               line="173">the object the asynchronous operation was started with.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="res" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gio/giotypes.h"
               line="174">a #GAsyncResult.</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gio/giotypes.h"
               line="175">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="AsyncResult"
               c:symbol-prefix="async_result"
               c:type="GAsyncResult"
               glib:type-name="GAsyncResult"
               glib:get-type="g_async_result_get_type"
               glib:type-struct="AsyncResultIface">
      <doc xml:space="preserve"
           filename="gio/gasyncresult.c"
           line="29">`GAsyncResult` provides a base class for implementing asynchronous function results.

Asynchronous operations are broken up into two separate operations
which are chained together by a `GAsyncReadyCallback`. To begin
an asynchronous operation, provide a `GAsyncReadyCallback` to the
asynchronous function. This callback will be triggered when the
operation has completed, and must be run in a later iteration of
the thread-default main context (see
[method@GLib.MainContext.push_thread_default]) from where the operation was
initiated. It will be passed a `GAsyncResult` instance filled with the
details of the operation's success or failure, the object the asynchronous
function was started for and any error codes returned. The asynchronous
callback function is then expected to call the corresponding `_finish()`
function, passing the object the function was called for, the
`GAsyncResult` instance, and (optionally) an @error to grab any
error conditions that may have occurred.

The `_finish()` function for an operation takes the generic result
(of type `GAsyncResult`) and returns the specific result that the
operation in question yields (e.g. a [class@Gio.FileEnumerator] for a
"enumerate children" operation). If the result or error status of the
operation is not needed, there is no need to call the `_finish()`
function; GIO will take care of cleaning up the result and error
information after the `GAsyncReadyCallback` returns. You can pass
`NULL` for the `GAsyncReadyCallback` if you don't need to take any
action at all after the operation completes. Applications may also
take a reference to the `GAsyncResult` and call `_finish()` later;
however, the `_finish()` function may be called at most once.

Example of a typical asynchronous operation flow:

```c
void _theoretical_frobnitz_async (Theoretical         *t,
                                  GCancellable        *c,
                                  GAsyncReadyCallback  cb,
                                  gpointer             u);

gboolean _theoretical_frobnitz_finish (Theoretical   *t,
                                       GAsyncResult  *res,
                                       GError       **e);

static void
frobnitz_result_func (GObject      *source_object,
		 GAsyncResult *res,
		 gpointer      user_data)
{
  gboolean success = FALSE;

  success = _theoretical_frobnitz_finish (source_object, res, NULL);

  if (success)
    g_printf ("Hurray!\n");
  else
    g_printf ("Uh oh!\n");

  ...

}

int main (int argc, void *argv[])
{
   ...

   _theoretical_frobnitz_async (theoretical_data,
                                NULL,
                                frobnitz_result_func,
                                NULL);

   ...
}
```

The callback for an asynchronous operation is called only once, and is
always called, even in the case of a cancelled operation. On cancellation
the result is a `G_IO_ERROR_CANCELLED` error.

## I/O Priority

Many I/O-related asynchronous operations have a priority parameter,
which is used in certain cases to determine the order in which
operations are executed. They are not used to determine system-wide
I/O scheduling. Priorities are integers, with lower numbers indicating
higher priority. It is recommended to choose priorities between
`G_PRIORITY_LOW` and `G_PRIORITY_HIGH`, with `G_PRIORITY_DEFAULT`
as a default.</doc>
      <source-position filename="gio/gasyncresult.h" line="62"/>
      <virtual-method name="get_source_object" invoker="get_source_object">
        <doc xml:space="preserve"
             filename="gio/gasyncresult.c"
             line="147">Gets the source object from a [iface@Gio.AsyncResult].</doc>
        <source-position filename="gio/gasyncresult.h" line="58"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gasyncresult.c"
               line="153">a new reference to the source
   object for the @res, or `NULL` if there is none.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncresult.c"
                 line="149">a [iface@Gio.AsyncResult]</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_data" invoker="get_user_data">
        <doc xml:space="preserve"
             filename="gio/gasyncresult.c"
             line="127">Gets the user data from a [iface@Gio.AsyncResult].</doc>
        <source-position filename="gio/gasyncresult.h" line="57"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gio/gasyncresult.c"
               line="133">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gio/gasyncresult.c"
                 line="129">a [iface@Gio.AsyncResult].</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_tagged" invoker="is_tagged" version="2.34">
        <doc xml:space="preserve"
             filename="gio/gasyncresult.c"
             line="210">Checks if @res has the given @source_tag (generally a function
pointer indicating the function @res was created by).</doc>
        <source-position filename="gio/gasyncresult.h" line="60"/>
        <return-value transfer-ownership="none">
     